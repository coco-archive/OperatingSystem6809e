  MAIN
**************************
* AN OPERATING SYSTEM FOR*
* 6809 MICRO BY          *
* DARRELL ULM            *
**************************
**PUBLIC VARS**(FOR EXTRN CODE)
 PUBLIC COMDSK
 PUBLIC FILE
 PUBLIC PIPE
 PUBLIC PIPLST
 PUBLIC EXIT
 PUBLIC PLIST
 PUBLIC FILSEM
 PUBLIC OPNSEM
 PUBLIC TOPPCB
 PUBLIC RUN
 PUBLIC OFT
 PUBLIC DSKREQ
 PUBLIC MEMHED
 PUBLIC SCRLOC
 PUBLIC DEVTAB
 PUBLIC DSKPIN
 PUBLIC DDH
 PUBLIC DDORG
 PUBLIC AN
 PUBLIC RQ

PROCZ EXT
EXPND EXT
EXECS EXT
PULLS EXT
PUSHS EXT
GOPENW EXT
GOPENR EXT
DKCLS EXT
ENDOS EXT
IOGO  EXT
OPENR EXT
OPENW EXT
DREAD EXT
DWRITE EXT
PIPRD EXT
WIPRD EXT

* ALL EQUS REPRESENT RELATIVE OFFSETS*

**DISK DRIVE VARIABLES**
LSTTRK EQU DSAVE   LAST TRACK TABLE
OUTTIM EQU DSAVE+4 TIME RUNOUT FLAG
NMIRET EQU DSAVE+5 NMI BRANCH LOCATION
COMPLT EQU DSAVE+7 COMPLETION FLAG
PARAMS EQU DSAVE+8 DRIVE SETUP SAVE
DELAY  EQU DSAVE+9 DELAY AFTER DONE
DSETUP EQU $FF40   PARAMS (DRIVE,DENSITY,WAIT)
STACOM EQU $FF48   COMMAND STATUS LOC
TRACK  EQU $FF49   TRACK TO SEEK
SECTOR EQU $FF4A   SECTOR TO USE
DDATA  EQU $FF4B   1 BYTE READ/WRITE

**IO REQUEST STRUCTURE**
IODEV  EQU 0       DEVICE 0-3
IORW   EQU 1       READ/WRITE 0-1
IOADD  EQU 2       ADDRESS TO DO TRANSFER
IOLEN  EQU 4       LENGTH OF TRANSFER
IONAME EQU 6       FILE NAME IF DEVICE 2
*                  PIN'S IF PIPE
IODR   EQU 17      DRIVE# IF DEV=2
IOL    EQU IODR+1  LENGHT OF THIS BLOCK

**MESSAGE BLOCK STRUCT**
TNXT   EQU 0   NEXT MESSAGE
TPIN   EQU 2   PIN OF SENDER
TLEN   EQU 4   MESS LENGTH
TDATA  EQU 6   MESSAGE DATA
TMLEN  EQU TLEN+2   MESS HEADER LENGTH

*MSG CONSTRUCTS FOR RECEIVER
TSEND  EQU 0   SENDER'S PIN
TL     EQU 2   LENGTH
TMSG   EQU 4   MSG LOC AFTER REC'ED

**SEMAPHORE**
SVAL   EQU 0   VALUE OF SEMP
SBLOC  EQU 2   LINK OF BLOCKED PCBS
SCNT   EQU 4   # PCBS BLOCKED
SOWN   EQU 6   LINK FROM PCB OWNING SEMP
SLEN   EQU SOWN+2    SEMP LENGTH

**MEM BLOCK**
MLEN   EQU 0   LENGTH OF THIS MEM BLOCK
MF     EQU 2   LINK TO NEXT
MB     EQU 4   LINK TO LAST
MTYPE  EQU 6   TYPE OF MEMORY
MPIN   EQU 8   PIN OF CREATOR
MDATA  EQU 10  DATA
ML     EQU MDATA   LENGTH OF MEM BLOCK

**PCB BLOCK**
PNAM   EQU 0    NAME OF PCB
PPIN   EQU 8    PIN OF PCB
PNXT   EQU 10   ACTIVE PCB CHAIN
PSTK   EQU 12   STACK POINTER
PHED   EQU 14   WHAT LINK PCB ON
PSEM   EQU 16   OWNED SEMP LIST
PCNT   EQU 18   COUNT OF INTERUPTS
PST    EQU 20   STATUS
PCHN   EQU 22   LINK OF ALL PCBS
PMSG   EQU 24   MESSAGES LINK
PREC   EQU 26   JUST RECIEVED MSG
PXE    EQU 28   MESSAGE EMPTY SEMP
PXF    EQU 36   MESSAGE FULL SEMP
PRD    EQU 44   IOREAD SPECIFIC TO PCB
PWT    EQU 46   WRT SPEC.
PJOB   EQU 48   JOB PROGRAM AREA
PEND   EQU 50   LOWER STACK LIMIT
PAREA  EQU 128  128 BYTES PER PCB
PL     EQU 128  PCB BLOCK LEN

**SWI OS SERVICE CALL ROUTINE NAMES**
**USE LDA #NAME**
CREATE EQU 0   CREATE PROCESS
DEST   EQU 1   DESTROY PROCESS
GET    EQU 2   GET MEMORY
FREE   EQU 3   FREE MEMORY
ALSEM  EQU 4   ALOCATE SEMP
FRSEM  EQU 5   FREE SEMP
P      EQU 6   MUTEX P OPERATOR
V      EQU 7   MUTEX V OPERATOR
SEND   EQU 8   SEND A MESSAGE
REC    EQU 9   RECEIVE A MESSAGE
WRITE  EQU 10  WRITE TO SCREEN
READ   EQU 11  READ FROM KEYS
DISK   EQU 12  ACCESS DISK
IO     EQU 13  CALL I/O WITH IO REQ BLOCK
OPENRD EQU 14  OPEN FOR READING
OPENWT EQU 15  OPEN FOR WRITING
READD  EQU 16  READ FROM DISK
CLOSE  EQU 17  CLOSE FILE
GOR    EQU 18  GENERAL OPEN READ
GOW    EQU 19  GENERAL OPEN WRITE
EXEC   EQU 20  EXECUTE A FILE
PULL   EQU 21  1ST SPACE
PUSH   EQU 22  1ST 'SPACE
EXPAND EQU 23  EXPAND FILE NAME
PROC   EQU 24  RETURN RUNNING

**INTERUPT JMP LOCATIONS**
INTJMP EQU $106 HARD WIRED JMP LOC
EXTJMP EQU $10C FOR TIME-SHARING
FIQJMP EQU $10F NOT USED
NMIJMP EQU $109 FOR DISK AT END OF OPERATION
IRQSPD EQU 18   CLOCK SPEED

**********************************
* START OF OS EXECUTION (INIT)   *
* ( INIT-SWI ALWAYS JUMPS TO $106*
*      SO CREATE JMP COMMAND  )  *
**********************************
INIT   LBRA    SAVE

**VARIABLE SAVE AREA**
WAITPN RMB 2     PIN OF WAIT PCB
PLIST  FDB 0     LIST OF ALL PCBS
OSMAIN RMB SLEN  SEMP FOR MAX NO. OF PCBS
KEYHIT RMB SLEN  SEMP USED BY KEYS ROUT
FILSEM RMB SLEN  FILE OPEN SEMP:INIT 0
OPNSEM RMB SLEN      OPEN(SWI)
TOPPCB FDB ENDOS+ML  ACTIVE PCB LIST HEAD
RUN    FDB ENDOS+ML  RUNNING PCB POINTER
DSKRQ  FCB 0         #DISK REQUESTS
PIN    FDB 0     CURRENT PIN
OFT    FDB 0     OPEN FILE TABLE
DSKREQ FCB 0     #DISK REQUESTS
PIPE   FCB 0     PIPE#
FILE   FCB 0     FILE#
PIPLST FDB 0     LIST OF ALL PIPES
MEMHED FDB ENDOS HEADER FOR MEM BLOCKS
SCRLOC FDB 1024  CURRENT VIDEO LOC
COMDSK FCB 0     DRIVE#
DSKPIN RMB 2     SECTOR RD/WT PIN

DEVTAB RMB 0    DEVICE PIN TABLE
KEYPIN RMB 2    KEYBOARD
SCPIN  RMB 2    SCREEN
RSIN   RMB 2    NOT USED
RSOUT  RMB 2    NOT USED
DSKIN  RMB 2    FILE IN
DSKOUT RMB 2    FILE OUT
PIPN   RMB 2    PIPE IN
PIPO   RMB 2    PIPE OUT

DDH FCB 2    READ DIRECTORY SETUP
    FCB 0    DR0
    FCB 17   DIRECTORY
    FCB 2    SECTOR
    FDB 400  LOC OF TRANSFER
    FCB 0    STATUS

**TEMPLATE FOR DISK ACCESS-256 BYTES**
DDORG  FCB 2    COMMAND
       FCB 0    DRIVE#
       FCB 17   TRACK
       FCB 2    SECTOR
       FDB 400  LOC OF TRANSFER
       FCB 0    STATUS

**MEM BLOCK TYPES**
FR     FCC /FR/   FREE
AN     FCC /AN/   ANY
PC     FCC /PC/   PCB
SM     FCC /SM/   SEMAPHORE
MS     FCC /MS/   MESSAGE
RQ     FCC /RQ/   IOREQUEST

SETUP  FCC /SETUPPCB/  BOOT-UP PCB
       FDB 0
       FDB 0
       FDB SETUP+PL
       RMB 128
INITD  FCC /INIT PRC/   INIT PROCESS NAME
       FDB INITPR       AND ADDRESS

**PROCESS STATES**
RN     FCC /RN/      RUN
BL     FCC /BL/      BLOCKED
RY     FCC /RY/      READY

**START OF OS**
SAVE   ORCC  #80     DISABLE TIMING INTS
       CLR   113     SET RESET
       LDX   #1      SET BOX COUNT TO 1
       STX   PIN     AND PIN AS WELL
       LDA   $FF03   SET UP 60MS TIMER
       ORA   #3
       STA   $FF03
       LDA   $FF01
       ANDA  #$FE
       STA   $FF01
       LDA   #$7E    BUILD JMP COMMAND
       STA   NMIJMP  AT INTERUPT LOCS
       STA   INTJMP
       STA   EXTJMP
       STA   FIQJMP
       LDX   #NMIINT    SAVE JMP LOCS
       STX   NMIJMP+1
       LDX   #EXTINT
       STX   EXTJMP+1
       LDX   #SWIINT
       STX   INTJMP+1
       LDX   #FSTINT
       STX   FIQJMP+1
       CLR   $FFDF     64K MODE

       LDX   #KEYRES   SETUP KEYBOARD BUFFER
       STX   KEYIND
       LDX   #ENDOS  GET END OF MEMORY ADD
       LDD   #0      SET UP 1ST MEM BLOCK
       STD   MF,X    NULL FORWARD
       STD   MB,X    NULL BACK
       STD   MPIN,X  PIN=0
       LDD   FR      =FREE BLOCK
       STD   MTYPE,X
       LDD   #40480  MAX MEM IN OS
       STD   MLEN,X

**SETUP #ACTIVE PCB & ANY HEY HIT SEMP**
       LDX   #OSMAIN    GET SEM ADDRESS
       LDD   #0         THIS IS MAX PCB SEMP
       STD   SBLOC,X    0 ARE BLOCKED
       STD   SCNT,X     COUNT=0
       STD   SOWN,X      NOT OWNED
       LDD   #20        INIT VALUE=10
       STD   SVAL,X
       LDX   #KEYHIT    GET SEM ADDRESS
       LDD   #0         THIS IS KEY SEMP
       STD   SBLOC,X    0 ARE BLOCKED
       STD   SCNT,X     COUNT=0
       STD   SOWN,X      NOT OWNED
       LDD   #0         INIT VALUE=0
       STD   SVAL,X
       LDX   #FILSEM    SETUP FILE SEMP
       LDD   #0
       STD   SBLOC,X
       STD   SCNT,X
       STD   SOWN,X
       LDD   #0
       STD   SVAL,X
       LDX   #OPNSEM    SETUP SEMP FOR MUTEX FOR FILE OPEN COMS
       LDD   #0
       STD   SBLOC,X
       STD   SCNT,X
       STD   SOWN,X
       LDD   #1
       STD   SVAL,X

       LDX   #SETUP  GET ADD OF FAKE PCB
       STX   RUN     SAVE IN RUNN
       TFR   X,S     SET STACK TO FAKE PCB
       LEAS  PL,S
       LDX   #INITD  MAKE INIT PROC
       LDA   #CREATE
       SWI
       LDX   TOPPCB  RUN=TOPPCB
       STX   RUN
       LBRA  DISPAT  START OS:GO DISPAT
*---------------------------------
* DISPATCHER: GIVES A PCB SOME

DISPAT LDX   RUN     GET RUNNING PCB
       INC   1024    SHOW OPERATION
       LDS   PSTK,X  GET STACK FROM RUN
       TFR   S,U     STCK INTO U
       LEAU  12,U    ADJUST FOR PULL
       STU   PSTK,X  SAVE BACK IN PCB
       RTI             START UP THIS PCB
*----------------------------------------
* TIMER INTERUPT HANDLER: SETS UP TO
*   JMP TO DISPAT TO GIVE OTHER PCB TIME
EXTTMP RMB 2
EXTCNT FCB IRQSPD

EXTINT TST  EXTCNT   TIME TO LOOK FOR A KEY?
       BNE  KEYOUT   NO
       LDA  #IRQSPD  ELSE RESET COUNTER
       STA  EXTCNT   AND CONTINUE
       LDA  $FF03   DISK DRIVE RUNNING?
       BPL  NOATTC  NO
       LDA  COMPLT  YES, DONE WITH TASK?
       BEQ  NOATTC  YES
       DECA         NO DEC TIMER
       STA  COMPLT  SAVE TIMER
       BNE  NOATTC  DONE?
       LDA  PARAMS  YES,STOP DRIVE
       ANDA #$B0
       STA  PARAMS
       STA  $FF40

NOATTC LDA  $FF02   RESET PIAS
       LDA  $FF00
       JMP  KEYHND  GET KEY IN BUFFER
KEYOUT INC  1025    SHOW OPERATION
       DEC  EXTCNT  DEC KEYPOLL COUNTER
       LDA  $FF01   SET UP PIA AGAIN
       ANDA #$7F
       STA  $FF01
       LDA  $FF03
       ANDA #$7F
       STA  $FF03

       LDX  RUN     GET RUNNING PCB
       STS  PSTK,X  SAVE PCB STATE
       LDU  PNXT,X  GET NEXT PCB
       LDY  PPIN,U
       CMPY WAITPN  IS THE WAIT PCB
       BNE  REGEXT  THE ONLY READY PCB?
       STX  EXTTMP  IF SO THEN RUN IT ELSE
       CMPU EXTTMP  SKIP IT
       BEQ  REGEXT
       LDU  PNXT,U
REGEXT STU  RUN     MAKE IT RUN
       LBRA DISPAT  DISPAT IT
*------------------------------------
**FIRQ HANDLER NOT USED**
FSTINT INC     1026
       RTI
*------------------------------------
* SERVICE CALL(SWI) INTERUPT ROUTINE
*    GIVES CALLING PROCESS A SERVICE

SWIINT LSLA         A=ROUTINE NUMBER
       LDU  RUN     GET RUN
       STS  PSTK,U  SAVE MODIFIED STACK IN PCB
       LDU  #STAB   GET TABLE ADDR
       JMP  [A,U]   JMP ROUTINE

STAB FDB CRE     ROUTINE TABLE
 FDB DES
 FDB GT
 FDB FRE
 FDB ALS
 FDB FRS
 FDB PP
 FDB VV
 FDB SSEND
 FDB RREC
 FDB WWRITE
 FDB RREAD
 FDB DSKSEC
 FDB IOGO
 FDB OPENR
 FDB OPENW
 FDB DREAD
 FDB DKCLS
 FDB GOPENR
 FDB GOPENW
 FDB EXECS
 FDB PULLS
 FDB PUSHS
 FDB EXPND
 FDB PROCZ

*------------------------------------
* EXIT: CALLED AT END OF EACH SWI 
*   ROUTINE

EXIT   LDU  RUN     GET RUN
       LDY  PSTK,U  FIX STACK TO RETURN
       LEAY 12,Y    TO CALLINF PCB
       STY  PSTK,U
       PULS PC,U,Y,X,DP,B,A,CC   RETURN
*------------------------------------
* CREATE PCB: MAKES A NEW PROCESS

CRE    TFR  X,U     SAVE INPUT PARAM
       LDX  #OSMAIN LIMIT ON #OF PROCS
       LDA  #P
       SWI          P ON MAIN SEMAPHORE
       TFR  U,X     RESTORE LOST VAR
       LEAU 0,X     WANT MEM BLOCK SIZE
       LDX  #PL     OF PCB LENGTH
       LDB  PC      GET PCB BLOCK
       LDA  #GET
       SWI          GET A MEMORY BLOCK
       LDD  0,U     X=MEM LOC
       STD  0,X     MOVE PCB NAME
       LDD  2,U
       STD  2,X
       LDD  4,U
       STD  4,X
       LDD  6,U
       STD  6,X
       LDD  PIN     SET PIN
       STD  PPIN,X
       CMPD #1      SPECIAL LINK FOR 1ST PCB
       BNE  NORM    NORMAL PCB CASE
       STX  PNXT,X  LINK TO ITSELF
       BRA  SET
NORM   LDY  RUN     GET RUN
       LDD  PNXT,Y  GET RUN.NEXT
       STD  PNXT,X  LINK IN NEW PCB
       STX  PNXT,Y  AFTER RUNNING
SET    LEAY PAREA-2,X     SETUP STACK
       LDD  8,U           GET PC->D
       STD  PJOB,X
       STD  ,--Y    SAVE PC
       LDD  #0
       STD  ,--Y    CLEAR U
       STD  ,--Y    CLEAR Y
       STD  ,--Y    CLEAR X
       STA  ,-Y     CLEAR DP
       STD  ,--Y    CLEAR A,B
       LDB  #$C0
       LDA  0,U
       CMPA #$26    =&?
       BNE  REGFS
       LDB  #$D0    SETUP CC
REGFS  STB  ,-Y
       STY  PSTK,X  SAVE S STACK POINTER
       LDD  #0      CLEAR PCB HEAD
       STD  PHED,X
       STD  PSEM,X  CLEAR SEMP LIST
       STD  PCNT,X    " INT COUNT
       STD  PST,X     " STATUS
       STD  PCHN,X    " CHAIN LINK
       STD  PREC,X    " MESS REC
       STD  PMSG,X    " MESS LINK
       STD  PXF+SVAL,X    SETUP MESSAGE SEMP
       STD  PXF+SCNT,X    MAX=10 MESSAGES
       STD  PXF+SBLOC,X
       STD  PXF+SOWN,X
       STD  PXE+SCNT,X
       STD  PXE+SBLOC,X
       STD  PXE+SOWN,X
       LDD  #10
       STD  PXE+SVAL,X

       LDU  PLIST   LINK NEW PCB INTO
       CMPU #0      ENTIRE PCB LIST
       BNE  STIC
       STX  PLIST   LIST EMPTY,INSERT 1ST
       BRA  GOOGZ
STIC   STU  PCHN,X  ELSE INSERT PCB AT TOP
       STX  PLIST

GOOGZ  LDD  RY
       STD  PST,X   MAKE STAUS READY

       LDU  PIN
       LDX  RUN     RETURN PIN OF CREATD PCB
       LDX  PSTK,X
       STU  4,X
       LEAU 1,U     UP PIN VALUE
       STU  PIN
       LBRA EXIT    GO EXIT

*---------------------------------
* GET: GIVES SOME MEMORY TO CALLER

TOTSAV RMB  2   TOTMEM
SMSAV  RMB  2   LENGTH NEEDED
B7     RMB  2   GEN USE
B6     RMB  2

GT     CMPX #32768  SEE IF A GOOD LENGTH
       BHI  GDES    NO?->DESTROY
       CMPB RQ      =IOREQUEST
       BNE  ANG1    NO
       BEQ  GOK     BAD LENGTH
ANG1   CMPB AN      =ANY?
       BEQ  GOK     YES,REQ=OK
       CMPB MS      =MSG?
       BNE  GT1     NO,ANOTHER TYPE?
       BRA  GOK     ELSE=OK
GT1    CMPB PC      =PCB?
       BNE  GT2     NO,ANOTHER
       CMPX #PL     PCB LEN?
       BEQ  GOK     CHECKS=OK
GDES   LDA  #DEST   BAD LEN->DESTROY CALLER
       SWI
GT2    CMPB SM      =SEMP?
       BNE  GDES    NO->BAD TYPE REQ,DESTROY
       CMPX #SLEN   SEMP LEN?
       BNE  GDES    BAD LEN->DESTROY

GOK    LEAU ML,X    LEN+MEMLEN
       STU  TOTSAV  SAVE R3- TOT MEM NEEDED
       STX  SMSAV   REG LENGTH NEEDED
       LDX  MEMHED  FIND FREE BLOCK
FREFND LDU  MTYPE,X GET TYPE
       CMPU FR      FREE?
       BEQ  MEMFND  FOUND FREE!
       LDX  MF,X    GET NEXT BLOCK
       BRA  FREFND  KEEP LOOKING

MEMFND LDU  MLEN,X  SEE IF FITS IN MEM
       CMPU SMSAV   =AMNT NEEDED?
       BEQ  CASE1   2 POSSIBLE CASES
       CMPU TOTSAV  >NEEDED?
       BHS  CASE2   YES->CASE2
       LDX  MF,X    ELSE GET NEXT BLOCK
       CMPX #0      NULL?
       BNE  FREFND  NO,KEEP GOING
       LDA  #DEST   OUT OF MEM->DES CALLER
       SWI             YES!, KILL THE BLOCK

CASE1  CMPB MS      LOAD CORRECT MEM TYPE
       BNE  NEW2    MESSAGE?
       LDU  MS
       BRA  TST
NEW2   CMPB AN      ANY?
       BNE  NEW
       LDU  AN
       BRA  TST
NEW    CMPB PC      PC?
       BNE  NEWS
       LDU  PC
       BRA  TST
NEWS   CMPB RQ      IORQ?
       BNE  NEWS1
       LDU  RQ
       BRA  TST
NEWS1  LDU  SM      SEMP
TST    STU  MTYPE,X SAVE TYPE
       LDU  RUN     GET CREATOR PIN
       LDY  PPIN,U  SAVE IN MEM BLOCK
       STY  MPIN,X
       LEAX MDATA,X GET ADD OF DATA SEGMENT
       LDU  RUN     GET RUN
       LDU  PSTK,U  GET STACK OF RUN
       STX  4,U     SET MEM BLOCK ADD IN X
       LBRA EXIT    RETURN

CASE2  CMPB MS      SET CORRECT MEM TYPE
       BNE  NEW22   MESSAGE?
       LDU  MS
       BRA  TST2
NEW22  CMPB AN      ANY?
       BNE  NEW33
       LDU  AN
       BRA  TST2
NEW33  CMPB SM      SEMP?
       BNE  NEEK
       LDU  SM
       BRA  TST2
NEEK   CMPB RQ      IORQ?
       BNE  NEEK2
       LDU  RQ
       BRA  TST2
NEEK2  LDU  PC      PCB
TST2   STU  MTYPE,X SAVE TYPE
       LDU  RUN     GET PIN OF CREATOR
       LDY  PPIN,U
       STY  MPIN,X  PUT INTO MEM BLOCK
       LEAU MDATA,X GET DATA ADDRESS
       TFR  U,D
       ADDD SMSAV   ADD LENGTH OF REQ
       TFR  D,U     U=NEW MEM BLOCK ADDR
       LDD  MLEN,X  GET LENGTH
       SUBD TOTSAV  SUB LENGTH FROM TOTAL
       STD  B6      SAVE IN TEMP
       LDY  SMSAV   GET LENGTH IN ORIG BLOCK
       STY  MLEN,X  SAVE NEW LENGTH
       LDY  MF,X    GET FORWARD PTR
       STY  B7      SAVE IN TEMP
       STU  MF,X    NEW FORWARD POINTER

       LDY  B6      GET NEW LENGTH
       STY  MLEN,U  SAVE IT
       LDY  B7      GET OLD FOWARD PTR
       STY  MF,U    SET NEW MEM FORWARD
       STX  MB,U    AND BACK
       LDY  FR      TYPE IS FREE
       STY  MTYPE,U
       LDY  #0      FREE BLK CRTED BY NO-ONE
       STY  MPIN,U

       LDY  B7      GET MF
       CMPY #0      NULL?
       BEQ  GDONE   NO MF LINK=DONE
       STU  MB,Y    FIX BACK

GDONE  LDU  RUN     SET X IN RETURN TO
       LDU  PSTK,U  ADD OF REQUESTED MEM BLOCK
       LEAX ML,X
       STX  4,U
       LBRA EXIT    RETURN
*------------------------------------
* FREE-FREES A MEMORY BLOCK, BACK INTO
*   POOL OF FREE BLOCKS

C7     RMB  2  TMP VARS
C1     RMB  2
C8     RMB  2

FRE    TFR  X,D     SAVE ADD TO FREE
       SUBD #ML     LENGTH OF HEADER
       STD  C1
       LDX  MEMHED  VERIFY REQUESTED BLOCK
FRFIND CMPX C1      IS REQ IN LIST?
       BEQ  FRFND   YES
       CMPX #0
       LBEQ FRKILL  =0 THEN DESTROY REQUESTING PCB
       LDX  MF,X    ELSE GET NEXT BLOCK
       BRA  FRFIND  LOOP

FRFND  LDU  FR      FOUND IT
       STU  MTYPE,X FIND FREE BLOCK
       LDY  MF,X    FIND MATCHING ADD
       CMPY #0      NULL?
       BEQ  FRBACK  CHECK BEHIND BLOCK
       CMPU MTYPE,Y
       BNE  FRBACK
       LDU  MF,Y    STORE FRONT&BACK PTRS
       STU  C7
       LDU  MLEN,Y
       STU  C8
       LDU  C7
       CMPU #0
       BEQ  FRCUR   NO FORWARD
       STX  MB,U
FRCUR  STU  MF,X    ELSE FIX FRONT PTR
       LDD  C8
       ADDD MLEN,X  COMPUTE NEW LENS
       ADDD #ML
       STD  MLEN,X
FRBACK LDU  MF,X    FIX BACK PTR
       STU  C7
       LDU  MLEN,X
       STU  C8
       LDU  MB,X
       CMPU #0
       BEQ  FREND   DONE

       LDD  FR      LOOK FOR BACKFREE BLK
       CMPD MTYPE,U IS IT FREE?
       BNE  FREND   NO
       LDD  C7      YES
       STD  MF,U    NOW HAS NEW FRONT PTR
       LDD  C8      COELESCE
       ADDD MLEN,U  GET NEW LEN
       ADDD ML
       STD  MLEN,U

       LDY  C7      POINT FRWD TO NEW BLOCK?
       CMPY #0      NULL?
       BEQ  FREND   THEN END
       STU  MB,Y    FIX FWD BACK LINK
       BRA  FREND
FRKILL LDA  #DEST   PROBLEM,DESTROY!
       SWI
FREND  LBRA EXIT
*------------------------------------
*DESTROY THE RUNNING PROCESS (SUICIDE)
*
TEMP   RMB  2

DES    LDX  RUN     FREE MBOXES
       LDX  RUN     GET RUNNING AGAIN
       LDU  PSEM,X  GET OWEND CHAIN
SCRAG  CMPU #0      DONE?
       BEQ  DZOW
       TFR  U,X     FREE SEMAPHORE
       LDA  #FRSEM
       SWI
       LDU  SOWN,U     GET NEXT SEMP
       BRA  SCRAG
*
DZOW   LDX  RUN     GET RUNNING
       LDY  PREC,X  GET JUST RECIEVED ADD
       CMPY #0      IS THERE ONE?
       BEQ  UNCH    NO
       LEAX 0,Y     ADJUST
       LDA  #FREE   FREE IT
       SWI
*
UNCH   LDX  PLIST   FREE FROM MSG CHAIN
       CMPX RUN     SAVE PIN AS RUN?
       BNE  REGBK   NO
       LDU  PCHN,X  YES UNCHAIN IT
       STU  PLIST
       BRA  COUGH
REGBK  CMPX RUN     SCAN PCBS FOR DEST PCB
       BEQ  BKIT    GOT IT SO FREE IT
       TFR  X,U     ELSE GET NEXT PCB IN LIST
       LDX  PCHN,X
       BRA  REGBK
BKIT   LDY  PCHN,X  FOUND IT, TAKE OUT OF LIST
       STY  PCHN,U

COUGH  LDX  #OSMAIN ONE MORE PROC AVAIL
       LDA  #V      SO V ON PCB SEMP
       SWI
       LDX  RUN     WAS PCB CREATED BY "EXEC"?
       LDA  PNAM,X
       CMPA #33
       BNE  NOTJOB  NO
       LDX  PJOB,X  YES SO
       LDA  #FREE   FREE EXEC JOB
       SWI
NOTJOB LDA  #FREE
       LDX  RUN     FREE RUNNING
       SWI

       LDX  RUN     UNLINK RUN PCB
       STX  TEMP
LLOOP  LDU  PNXT,X  FIND ONE LINKED TO IT
       CMPU TEMP    =?
       BEQ  DGO     YES, UNCHAIN IT
       TFR  U,X     ELSE UP CHAIN
       BRA  LLOOP   AGAIN
DGO    LDY  PNXT,U  GET NEXT OF RUNNING
       STY  PNXT,X  JUMP OVER THIS PCB
       CMPU TOPPCB  TOP?
       BNE  DEND    DO DISPAT
       STY  TOPPCB  NEW TOP
DEND   STY  RUN     NEW RUN
       LBRA DISPAT  DISPATCH!
*-----------------------------------
* FREE SEMAPHORE (X)=SEMAPHORE TO FREE
*
D0     RMB  2       TEMP VARS
D6     RMB  2

FRS    STX  D0      R0=SEMP ADDRESS=X
       LDX  RUN     X=RUNNING
       LDU  PSEM,X  SEE IF SEMP OWNED BY RUN
FSLP   CMPU #0      NULL?
       BEQ  WASIT   DESTROY RUNNING
       CMPU D0      =TO SENT SEMP?
       BEQ  FRIT    YES,FREEIT
       TFR  U,Y     SAVE U IN Y
       LDU  SOWN,U  GET NEXT SEMP
       BRA  FSLP

WASIT  LDA  #DEST
       SWI          DEST RUNNING

FRIT   STU  D6      SAVE SEMP ADD
       LDU  PSEM,X  SEE IF SAME IN PCB
       CMPU D6
       BNE  FRIT2   NO SO FREE FROM LIST
       LDU  D6      ELSE,NULL PCB
       LDY  SOWN,U  LINK AROUND SEMP
       STY  PSEM,X
       BRA  SFREND  GO TO END

FRIT2  LDU  D6      GET OLD ADD BACK
       LDU  SOWN,U
       STU  SOWN,Y

SFREND LDX  D0
       LDA  #FREE   FREE SEMAPHORE
       SWI
       LBRA EXIT
*------------------------------------
* ALLOCATE SEMAPHORE (X)=VALUE
* RETURNS (X)=SEMAPHORE ADD.

ALS    TFR  X,Y     SAVE SEMP VAL->Y
       LDX  #SLEN   GET SEMP BLOCK
       LDB  #83
       LDA  #GET
       SWI             X=LOC OF NEW SEMP
       STY  SVAL,X  SAVE VALUE
       LDD  #0      0 OTHER LOCS
       STD  SBLOC,X
       STD  SCNT,X
       LDU  RUN     U=RUNNING PCB
       LDY  PSEM,U  CHAIN SEMP ONTO RUNPCB
       STX  PSEM,U  REROUTE PCB
       STY  SOWN,X  REROUTE SEMP TO OLD SM
       LDU  PSTK,U  GET STACK PTR
       STX  4,U     CHANGE X TO SEMP ADD
       LBRA EXIT
*------------------------------------
* UP OR V: (X)=SEMAPHORE ADD.

VV     LDU  SBLOC,X X=SEM GET BLOCKED PCBS
       CMPU #0      ANY BLOCKED?
       BNE  VUNBL   YES,PULL 1ST OFF
       LDY  SVAL,X  NO CHANGE SEMP VALUE
       LEAY 1,Y
       STY  SVAL,X  VAL=VAL+1
       BRA  VEND    DONE!

VUNBL  LDY  PNXT,U  GET NEXT.NEXT OF FIRST
       STY  SBLOC,X AROUND NEW PCB
       LDY  SCNT,X  CHANGE COUNT
       LEAY -1,Y
       STY  SCNT,X
       LDY  #0      NEXT =0
       STY  PNXT,U
       LDY  RY      STATUS IS NOW READY
       STY  PST,U

       LDX  RUN     GET RUNNING
       LDY  PNXT,X  GET ITS LINK
       STY  PNXT,U  LINK INTO LIST
       STU  PNXT,X
VEND   LBRA EXIT
*-----------------------------------
* DOWN OR P: (X)=ADDRESS OF SEMP

E11    RMB  2       TEMP

PP     LDD  SVAL,X  X=SEMP LOC
       CMPD #0      ARE THERE 0 RESC LEFT?
       BHI  PPNORM  JUST SUB 1
       LDU  RUN     GET RUN
       LDY  PNXT,U  GET NEXT PCB
       STY  E11     SAVE NEXT PTR
PLOOP  CMPY RUN     WHAT POINTS TO RUN?
       BEQ  PFIND   FOUND IT!
       TFR  Y,U     OLD->U
       LDY  PNXT,Y  GET NEXT
       BRA  PLOOP

PFIND  CMPY TOPPCB  IS IT THE TOP ONE?
       BNE  PHARD
       LDD  PNXT,Y  FIX TOP DECHAIN
       STD  PNXT,U
       STD  TOPPCB
       BRA  PGOGO

PHARD  LDD  PNXT,Y  DECHAIN PCB FROM RDY
       STD  PNXT,U  LINK AROUND
PGOGO  LDD  SBLOC,X BLOCK THE SUCKER
       CMPD #0      ANY BLOCKED?
       BNE  INPCBS  YUP
       STY  SBLOC,X NO,BLOCK IT
       BRA  PPDIS

INPCBS CMPU #0      GO TO END OF Q
       BEQ  BLOCIT
       TFR  U,D     KEEP LAST PCB
       LDU  PNXT,U  GET NEXT ONE
       BRA  INPCBS  KEEP LOOKING

BLOCIT TFR  D,U
       STY  PNXT,U  FIX LINK
PPDIS  LDD  #0      FIX-UP MOVED PCB
       STD  PNXT,Y  CLEAR NEXT LINK
       STX  PHED,Y  POINT TO SEMP
       LDD  BL      STATUS=BLOCKED
       STD  PST,Y
       LDD  SCNT,X  CHANGE COUNT
       ADDD #1
       STD  SCNT,X
       LDY  E11
       STY  RUN     FIX NEW RUNNING
       LBRA DISPAT

PPNORM LDD  SVAL,X  CASE #2
       SUBD #1      SUBTRACT 1 FROM VAL
       STD  SVAL,X  SAVE IN SEMP
       LBRA EXIT    EXIT

*-----------------------------
* STANDARD ERROR ROUTINE
* PASSI BACK (X)=-1
CAN2   LDX  RUN     GET RUN
       LDU  PSTK,X  GET SAVE STACK
       LDY  #-1     SAVE -1 IN
       STY  4,U     REG (X)
       LBRA EXIT
*-----------------------
* SEND: X=PIN Y=ADD OF
*   LEN+MSG
T0     RMB  2       TEMP
T1     RMB  2

SSEND  LDU  PLIST   GET TOP & LOOK FOR PIN
LOOP1  CMPX PPIN,U  SAME PIN AS PCB?
       BEQ  FNDP    YES, FOUND IT
       LDU  PCHN,U  NO, KEEP LOOKING
       CMPU #0      END OF LIST?
       BNE  LOOP1   YES, ERROR!
       LBRA CAN2    RET -1

FNDP   LDX  ,Y      GET LEN
       LEAX TMLEN,X ADD MSG LEN
       LDB  MS      GET MSG
       LDA  #GET
       SWI
       STY  T0      SAVE BUFF
       LDY  RUN     GET RUN PIN
       LDY  PPIN,Y
       STY  TPIN,X  SAVE IN MSG
       CLR  TNXT,X  CLEAR Q LINK
       CLR  TNXT+1,X
       LDY  T0      GET BUFF
       STX  T0      SAVE MSG ADD
       STU  T1      SAVE PCB ADD
       LDU  ,Y      U=LEN
       LEAU 2,U
       LEAX TLEN,X  P MSG BASE
LOOP2  LDA  ,Y+     GET BYTE
       STA  ,X+     SAVE BYTE IN MSG
       LEAU -1,U    LESS DATA
       CMPU #0      DONE?
       BNE  LOOP2   NO

       LDY  T0      Y=MSG
       LDU  T1      U=PCB
       LEAX PXE,U   P AND EMPTY
       LDA  #P
       SWI

       LDX  PMSG,U  GET MSG Q
       CMPX #0      ANY MSGS?
       BNE  HARDS   YES
       STY  PMSG,U  NO, SAVE NEW MSG
       BRA  TAKEAV  GO END

HARDS  TFR  Y,D     MSG ADD INTO D
LOOP3  CMPX #0      END OF Q?
       BEQ  SAVEDI  YES
       TFR  X,Y     NO SAVE X IN Y
       LDX  TNXT,X  GET NEXT MSG
       BRA  LOOP3
SAVEDI STD  TNXT,Y  SAVE MSG ON Q

TAKEAV LEAX PXF,U   V ON FULL
       LDA  #V
       SWI
       LDX  RUN     GET RUN
       LDU  PSTK,X  RET 0 IN X
       LDY  #0
       STY  4,U
       LBRA EXIT
*--------------------------
*RECEIVE  = NO PARAMS
*  PASSES BACK ADD OF MSG

RREC   LDU  RUN     REC A MSG
       LDX  PREC,U
       CMPX #0      FREE JUST RECEIVED?
       BEQ  ROTH    NO
       LDA  #FREE   YES, FREE IT
       SWI
       CLR  PREC,U
       CLR  PREC+1,U
ROTH   LEAX PXF,U   P ON FULL
       LDA  #P
       SWI
       LDY  PMSG,U  DE Q MSG
       LDD  TNXT,Y  LINK AROUND
       STD  PMSG,U
       STY  PREC,U  NEW REC MSG
       LEAX PXE,U   V ON EMPTY
       LDA  #V
       SWI
       LEAY 2,Y     ADJUST FOR PIN
       LDX  RUN     RET ADD OF MSG
       LDU  PSTK,X
       STY  4,U
       LBRA EXIT    DONE!

*--------------------------
* KEYS-READS KEY STROKES
* (X)=ADD (B)=LEN

KEYBLK RMB  IOL      FOR COPY OF IOREQUEST

RREAD  LDU  #KEYBLK  GET BUFFER ADD
       CLR  IODEV,U  DEV=0
       CLR  IORW,U   =READ
       STX  IOADD,U  SAVE ADD
       CLR  IOLEN,U  PUT REG B IN LEN
       STB  IOLEN+1,U
       LDA  #IO      GO IO REQ
       TFR  U,Y
       SWI
       LBRA EXIT     END

*-----------------------------
* KEYBOARD SCREEN IO HANDLER
*  (PROCESS)

KPINSV RMB  2        PIN OF REQUESTER
KERRM  FDB  1        LENGTH TRANSFERRED
       FCB  0        ERROR

KKEYS  LDA  #REC     WHEN RECS MSG WILL
       SWI           WAKE UP PROCESS
       STX  KPINSV   SAVE IN PIN AREA
       LEAX TMSG,X
       LDB  IOLEN+1,X
       LDU  IOADD,X  BUFF ADDR->U
KEYR   LDX  #KEYHIT  YES SO WAIT TILL KEY
       LDA  #P       HIT
       SWI
       LDY  KEYIND   ADJUST BUFFER INDEX
       LEAY -1,Y
       STY  KEYIND
       LDA  KEYRES   GET BYTE FROM KEY
       STA  ,U+      SAVE IN BUFFER
       LDX  #KEYRES+1
PHASE  LDA  ,X+         ADJUST BUFFER
       STA  -2,X
       CMPX #KEYRES+16
       BNE  PHASE
       DECB             -1 ON COUNT
       BNE  KEYR     GET ANOTHER
       LDA  #SEND    SEND MESSAGE BACK TO #IO
       LDX  KPINSV   RETURN LEN
       LDX  TSEND,X  ERR MSGS
       LDY  #KERRM
       SWI
       JMP  KKEYS    FINISHED WITH REQUEST

*--------------------------
* TERM-WRITES CHARS TO TERM
* (X)=ADD (B)=LEN

TFRBLK RMB  IOL       COPY REQ BUFF HERE

WWRITE LDU  #TFRBLK   GET BUFF ADD
       CLR  IODEV,U   DEV=0
       LDA  #1        =WRITE
       STA  IORW,U
       STX  IOADD,U   FIX ADD
       CLR  IOLEN,U   LEN=REG B
       STB  IOLEN+1,U
       LDA  #IO
       TFR  U,Y       DO IO REQUEST
       SWI
       LBRA EXIT

*----------------------------
* CONSOLE SCREEN IO HANDLER
* (PROCESS)

CONSV  RMB  2      TEMP VAR
TPINS  RMB  2      PIN OF REQUESTER
TERRM  FDB  1      LEN AND ERRS IN TRANSFER
       FCB  0

TTERM  LDA  #REC    REC' TO WAKE UP PROCESS
       SWI
       STX  TPINS   SAVE MSG ADD
       LEAX TMSG,X  MSG PART
       LDB  IOLEN+1,X
       LDU  IOADD,X U=I/O BUFF
       LDX  SCRLOC  GET SCREEN LOC
SOUTL  LDA  ,U+     GET DATA
       CMPA #12     CLEAR?
       BNE  NOCLR
       LDY  #1024   YES, BLACK OUT SCREEN
       LDA  #32
CLLP   STA  ,Y+
       CMPY #1536
       BNE  CLLP
       LDX  #1024
       LBRA NOBCK
NOCLR  CMPA #13     RETURN?
       BNE  NORET   NO,
       STD  CONSV
       LEAX 1,X     YES COMPUTE NEW ADD
       TFR  X,D     OF CURSOR AFTER A
       ADDD #31     RETURN
       ANDB #224
       TFR  D,X
       LDD  CONSV
       LBRA NOBCK
NORET  CMPA #8      BACKSPACE?
       BNE  PRINTY  NO
       LEAX -1,X
       CMPX #1023   YES,DEC LOCATION ON SCREEN
       BNE  NOBCK   BY ONE
       LEAX 1,X
       BRA  NOBCK
PRINTY CMPA #65     ADJUST ANY UPPER AND LOWER CASE
       BLO  PRNOW
       CMPA #90
       BHI  PRNOW
       SUBA #64
PRNOW  STA  ,X+
NOBCK  CMPX #1536   END OF SCREEN?
       LBGE SCROLL  YES
SCBK   DECB            1 LESS
       BNE  SOUTL   LOOP
       STX  SCRLOC
       LDX  TPINS   DONE, SEND MSG CONTAINING
       LDX  TSEND,X
       LDY  #TERRM  LEN AND ERRS TO SWI #IO
       LDA  #SEND
       SWI
       JMP  TTERM   BACK TO START

SCROLL LDY  #1056   SCROLL THE SCREEN UP
SCLP   LDA  ,Y+     WHEN CHARACTERS GO OFF THE
       STA  -33,Y   BOTTOM
       CMPY #1536
       BNE  SCLP
       LDX  #1504
       TFR  X,Y
       LDA  #32
SCLP2  STA  ,Y+
       CMPY #1536
       BNE  SCLP2
       LBRA SCBK    RETURN AFTER SCROLL
*----------------------------------------------
* THE INITIALIZATION PROCESS
* IS THE 1ST PROCESS STARTED
* WILL START ALL DEVICE DRIVERS
* AND THEN THE SHELL

CLSCN  FCB  12   STARUP MESSAGE
       FCB  13
       FCB  13
       FCC  /     --->BTOS<---     /
       FCB  13
       FCC  /     (SHELL)    /
       FCB  13
       FCB  13

INITPR LDX  #WTP1      CREATE ALL DEVICE DRIVERS
       LDA  #CREATE
       SWI
       STX  WAITPN
       LDX  #TRMPS
       LDA  #CREATE
       SWI
       STX  SCPIN
       LDX  #KEYPS
       LDA  #CREATE
       SWI
       STX  KEYPIN
       LDX  #DSKST
       LDA  #CREATE
       SWI
       STX  DSKPIN
       LDX  #DRDINT
       LDA  #CREATE
       SWI
       STX  DSKIN
       LDX  #DWDINT
       LDA  #CREATE
       SWI
       STX  DSKOUT
       LDX  #PPRINT
       LDA  #CREATE
       SWI
       STX  PIPN
       LDX  #PPWINT
       LDA  #CREATE
       SWI
       STX  PIPO
       LDA  #EXEC     START SHELL
       LDX  #SHELL
       SWI
       LDB  #44
       LDX  #CLSCN    WRITE STARTUP MSG
       LDA  #WRITE
       SWI

       LDA  #DEST     DESTROY INIT PROC
       SWI

*-------------------------
*  DRIVE PROCESS TABLE
*-------------------------
SHELL  FCC /SHELL   /
WTP1   FCC /WAIT    /
       FDB WAITP1
TRMPS  FCC /$TERMDRV/
       FDB TTERM
KEYPS  FCC /$KEYDRIV/
       FDB KKEYS
DSKST  FCC /&DISKDR /
       FDB DSKIO
DRDINT FCC /&DSKREAD/
       FDB DREAD
DWDINT FCC /&DSKWRTE/
       FDB DWRITE
PPRINT FCC /$PIPREAD/
       FDB PIPRD
PPWINT FCC /$PIPWRTE/
       FDB WIPRD

WAITP1 BRA WAITP1




