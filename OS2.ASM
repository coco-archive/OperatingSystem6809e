
**************
*-OS PART 2- *
*FILE SYSTEMS*
**************
**PUBLIC FILE VARS**
 PUBLIC PIPRD
 PUBLIC WIPRD
 PUBLIC ENDOS
 PUBLIC IOGO
 PUBLIC OPENR
 PUBLIC OPENW
 PUBLIC DREAD
 PUBLIC DWRITE
 PUBLIC IOL
 PUBLIC DKCLS
 PUBLIC GOPENW
 PUBLIC GOPENR

**EXTERNAL VARS**
PIPE EXT
FILE EXT
PIPLST EXT
OPNSEM EXT
PLIST EXT
FILSEM EXT
TOPPCB EXT
RUN EXT
OFT EXT
DSKREQ EXT
SCRLOC EXT
DEVTAB EXT
DSKPIN EXT
RQ EXT
AN EXT
DDH EXT
DDORG EXT
EXIT EXT

**OPEN FILE TABLE**
FST    EQU 0   R/W
FNAME  EQU 1   NAME
FDRIVE EQU 12  DRIVE
FGRAN  EQU 13  GRANULE
FLAST  EQU 14  #BYTES LAST SECTOR
FNUM   EQU 16  #FILE NUMBER
FBYTE  EQU 17  POINTER TO BUFFER
FNEXT  EQU 19  NEXT ENTRY
FBUFF  EQU 21  OFT BUFFER
FLEN   EQU FBUFF+2560

**DIR TABLE**
DRFN   EQU 0   NAME
DREXT  EQU 8   EXTENSION
DRFT   EQU 11  FILE TYPE
DRFM   EQU 12  FILE MODE
DRGRN  EQU 13  1ST GRAN
DRBYTE EQU 14  #BYTES LAST SECTOR
DRFUT  EQU 16  EXPANSION

**IO REQ BLOCK**
IODEV  EQU 0   DEVICE
IORW   EQU 1   READ/WRITE
IOADD  EQU 2   & TO START IO ON
IOLEN  EQU 4   #BYTES TO DO
IONAME EQU 6   NAME OF FILE
IODR   EQU 17  DRIVE# IF USED
IOL    EQU IODR+1

**PIPES**
PPNUM  EQU 0  PIPE NUMBER
PPRD   EQU 1  READER'S PIN
PPWT   EQU 3  WRITER'S PIN
PPEMP  EQU 5  EMPTY SEMP
PPFULL EQU 7  FULL SEMP
PPMUTX EQU 9  MUTX ON PIPE
PPCLS  EQU 11 OPEN=0 CLOSED=$FF
PPNEXT EQU 12 NEXT PIPE IN LIST
PPPCB  EQU 14 CHAINED TO PCB
PPPTR  EQU 16 BUFFER POINTER
PPBUFF EQU 18 BUFFER
PPBFLN EQU 16 LENGTH OF BUFFER
PPLEN  EQU PPBUFF+PPBFLN+2
**PCB**
PNAM   EQU 0
PPIN   EQU 8
PNXT   EQU 10
PSTK   EQU 12
PHED   EQU 14
PSEM   EQU 16
PCNT   EQU 18
PST    EQU 20
PCHN   EQU 22
PMSG   EQU 24
PREC   EQU 26
PXE    EQU 28
PXF    EQU 36
PRD    EQU 44
PWT    EQU 46
PJOB   EQU 48
PEND   EQU 50
PAREA  EQU 128
PL     EQU 128

**DISK READ/WRITE**
* +0 OPERATION
*    1=NOOP 2=READ 3=WRITE
* +1 DRIVE 0-3
* +2 TRACK 0-34
* +3 SECTOR 1-18
* +4 BUFFER ADDRESS (2 BYTES)

**MSG RECEIVER OFFSETS**
TSEND  EQU 0   SENDER'S PIN
TL     EQU 2   LENGTH
TMSG   EQU 4   MSG LOC AFTER REC'ED

**RETURN OF IO OPERATION**
ERRRET EQU 0   ERROR
LENRET EQU 1   # BYTES COMPLETED

CREATE EQU 0   CREATE PROCESS
DEST   EQU 1   DESTROY PROCESS
GET    EQU 2   GET MEMORY
FREE   EQU 3   FREE MEMORY
ALSEM  EQU 4   ALOCATE SEMP
FRSEM  EQU 5   FREE SEMP
P      EQU 6   MUTEX P OPERATOR
V      EQU 7   MUTEX V OPERATOR
SEND   EQU 8   SEND A MESSAGE
REC    EQU 9   RECEIVE A MESSAGE
WRITE  EQU 10  WRITE TO SCREEN
READ   EQU 11  READ FROM KEYS
DISK   EQU 12  ACCESS DISK
IO     EQU 13  CALL I/O WITH IO REQ BLOCK
OPENRD EQU 14  OPEN FOR READING
OPENWT EQU 15  OPEN FOR WRITING
RREAD  EQU 16  READ FILE
CLOSE  EQU 17  CLOSE FILE
WWRITE EQU 18  WRITE TO FILE

*------------------------------
*IO HANDLER: ALL IO REQUESTS
* INP: IO REQBLOCK IN Y
* OUT: A=ERRCODE 0=NONE 255=ERR
*      Y=#BYTES TRANSFERRED
*------------------------------
IOGO   LDA  IODEV,Y    GENERAL DEVICE?
       CMPA #255       YES
       LBNE IOSET      SET IO
       LDX  RUN        GET RUNNING
       TST  IORW,Y     TEST READ AND WRITE
       BNE  IWTCAS     GO WRITE CASE
       LDA  PRD,X      GET MAJ DEV#
       LDB  PRD+1,X    GET MINOR DEV#
       BRA  IOG11      GO INSERT INTO PCB
IWTCAS LDA  PWT,X      GET WT MAJ DEV#
       LDB  PWT+1,X    GET WT MIN DEV#
IOG11  CMPA #1         =SCREEN THEN DONE
       LBLS IOSET
       CMPA #3         =PIPE FIND MATCHING PIPE
       LBEQ IOPIPE
       STA  IODEV,Y    SAVE DEV IN REQ BLOCK
       TFR  B,A        MIN DEV INTO A
       LDX  OFT        FIND MATCHING FILE

IOLPS1 CMPA FNUM,X     SAME FILE#?
       LBEQ GOOFT      YES
       LDX  FNEXT,X    NO GET NEXT FILE
       CMPX #0         IF END OF LIST
       LBEQ IOERR        THEN ERROR
       BRA  IOLPS1     ELSE TRY AGAIN

GOOFT  CLRB            COPY THE FILE NAME
       LEAY IONAME,Y   WRITE TO THIS
       LEAX FNAME,X    READ NAME HERE
GOCPY  LDA  B,X
       STA  B,Y        COPY
       INCB
       CMPB #12        12 BYTES IN NAME
       BNE  GOCPY      LOOP
       LEAY -IONAME,Y  FIX POINTER
       LBRA IOSET      DONE

IOPIPE STA  IODEV,Y    SAVE DEV IN IOREQ
       LDX  PIPLST     FIND PIPE IN LIST
IOLPS2 CMPB PPNUM,X    SAME?
       LBEQ GOPIP      YES
       LDX  PPNEXT,X   ELSE GET NEXT
       CMPX #0         END OF LIST?
       LBEQ IOERR      YES,ERROR
       BRA  IOLPS2     ELSE LOOP

GOPIP  STB  IONAME+4,Y FIX PINS FOR PIPE IN NAME
       LDD  PPRD,X     READ PIN
       STD  IONAME,Y
       LDD  PPWT,X     WRITE PIN
       STD  IONAME+2,Y
**SET UP THE REQ BLOCK IN WHOLE**
IOSET  LDA  IODEV,Y  GET DEV#
       CMPA #3       VALID?
       BHI  IOERR    BAD DEVIC
       CMPA #2
       BNE  NODISK   N=2 NOT DISK
       LDA  IODR,Y   GET DRIVE #
       CMPA #3
       BHI  IOERR    INVALID DRIVE
NODISK LDA  IORW,Y   VALID OP?
       CMPA #1       0-1 ARE VALID
       BHI  IOERR
       LDD  IOLEN,Y  TOO HIGH LEN??
       CMPD #32768   ONLY 32K CAN BE TRANSFERRED
       BHI  IOERR    ELSE ERROR

       LDB  RQ       COPY IOREQ BLOCK
       LDX  #IOL+2   CREATE MESSAGE
       LDA  #GET     TO SEND TO PROPER
       SWI           DEVICE HANDLER
       LEAX 2,X      GO PAST LENGTH
       TFR  Y,U      PUT IOBLK ADD IN U
       LDB  #IOL     B=LEN OF RQU BLOCK
IOCPY  LDA  ,U+      COPY INFO
       STA  ,X+
       DECB          ONE LESS
       BNE  IOCPY    KEEP GOING

       LDD  #IOL+2   COMPUTE LEN OF REQBLOCK
       LEAX -IOL,X   START OF MESSGAGE
       LEAX -2,X
       STD  ,X       SAVE LEN OF REQBLK

       LDB  IODEV+2,X  COMPUTE DEVICE
       LSLB          IN DEVICE TABLE SO
       LSLB            MULT*4 FOR TABLE LOC
       TST  IORW+2,X READ OR WRITE?
       BEQ  NOWRT    READ CASE
       ADDB #2       WRITE!
NOWRT  TFR  X,Y      SEND MSG TO DEVICE HANDLER
       LDX  #DEVTAB  USE TABLE OF DEVICES
       LDX  B,X      GET PIN
       LDA  #SEND    START THE DEVICE DRIVER!
       SWI

       TFR  Y,X      FREE REQ BLOCK
       LDA  #FREE
       SWI

       LDA  #REC     WAIT SIGNAL FRM DEVICE DRIVER
       SWI
       LEAX TMSG,X   X=DATA PORTION
       LDY  RUN      RETURN ERR CODE
       LDU  PSTK,Y
       LDA  ERRRET,X GET ERR FROM DEVHAND
       STA  1,U      SAVE IN REG (A)
       LDX  LENRET,X GET #BYTES TRANSFERRED
       STX  6,U      RETURN IN Y
       LBRA EXIT     RETURN

IOERR  LDY  RUN      PASS BACK ERROR FLAG
       LDU  PSTK,Y
       LDA  #255     ERR=255
       STA  1,U      IN REG A
       LBRA EXIT

*-----------------
*UTILITY PROGRAMS
*-----------------
*COMPARE STRINGS AT Y,U LEN=B*
*EXIT B=0 STINGS MATCH       *
COMP   PSHS A,Y,U
CMPLP2 LDA  ,U+    COMPARE
       CMPA ,Y+
       BNE  NOCMP
       DECB
       BNE  CMPLP2
NOCMP  PULS U,Y,A
       RTS

*COPY X TO U LEN=B*
MOVE  PSHS A,X,U
MVELP LDA  ,X+
      STA  ,U+
      DECB         COPY
      BNE  MVELP
      PULS U,X,A
      RTS

*---------------------------------
*GENERAL OPEN (SET IO IN PCB)
*READ & WRITE
* IN:B=DEVICE#
*    U=&OF 1(FILE) OR 2(PIPE) PINS
*   IF FILE:
*    Y=ADDRESS OF FILE/EXT/DRV
*OUT:A=ERRCODE
*    B=FILE# OR PIPE#
*---------------------------------
OROW  RMB 1 READ=0 WRITE=1
GENR  RMB 1 GENIO=255 REG=0
DEVR  RMB 1 DEVICE#
RPIN1 RMB 2 READER PIN
RPIN2 RMB 2 WRITER PIN
GNPC1 RMB 2 READER PCB
GNPC2 RMB 2 WRITER PCB
PIPRET RMB 2 RETURN FROM MAKE PIPE

GOPENW LDA  #P       WAIT IF SOME OTHER
       LDX  #OPNSEM  DEVICE IS BEING OPENED
       SWI
       LDA  #1       SET FLAG FOR WRITE
       STA  OROW
       BRA  NATFLW   GO TO SHARED SECTION

GOPENR LDA  #P     MUTEX FOR ALL OPENS
       LDX  #OPNSEM
       SWI
       CLR  OROW   SET READ FLAG
NATFLW LDA  #255   SET DEV TO 255=GENERAL
       STA  GENR
       STB  DEVR   SAVE IN DEV FLAG
       LDX  ,U     GET PIN#1
       STX  RPIN1  SAVE IN TEMP
       LDX  2,U    GET PIN#2
       STX  RPIN2  SAVE IN TEMP

       LDX  PLIST  SEARCH ALL PCBS
OPINS  LDU  PPIN,X FOR PIN #1
       CMPU RPIN1  FOUND IT
       BEQ  GTRPN1 GO INSERT PIN
       LDX  PCHN,X ELSE GET NEXT
       CMPX #0     END OF PCBS?
       LBEQ OPNERR YES, ERROR
       BRA  OPINS  ELSE LOOP

GTRPN1 STX  GNPC1  SAVE PIN#1 IN TEMP
       CMPB #3     PIPE?
       LBNE OREALY NO, THEN DONT NEED ANOTHER PIN

       LDX  PLIST  SEARCH ALL PCBS FOR PIN W/ PIPE
OPINS2 LDU  PPIN,X SAME PNS?
       CMPU RPIN2
       BEQ  GTRPN2 YES, INSERT PIN#2 FOR PIPE
       LDX  PCHN,X ELSE NEXT
       CMPX #0     NO MORE PCBS?
       LBEQ OPNERR YES,ERROR
       BRA  OPINS2 ELSE LOOP

GTRPN2 STX  GNPC2  SAVE PIN IN TEMP
OREALY TST  OROW   BRANCH TO PROPER OPEN
       LBNE OREAWY ROUTINE BASED ON FLAG!
       BRA  OREADY
*--------------------------
*GET PIPE
* ALLOCATES A PIPE TO A PCB
*--------------------------
GPIPE  LDA  #GET    GET MEM FOR A PIPE
       LDX  #PPLEN  OF PIPE LENGTH
       LDB  AN      USE TYPE ANY
       SWI
       TFR  X,U      SAVE PIPE LOC IN U
       INC  PIPE     PIPE#=PIPE#+1
       LDA  PIPE     GET # OF PIPE
       STA  PPNUM,U  SAVE IN NEWPIPE
       LDD  RPIN1    SET READ PIN IN PIPE
       STD  PPRD,U
       LDD  RPIN2    SET WRITE PIN IN PIPE
       STD  PPWT,U
       LDA  #ALSEM   ALOCATE EMP SEMP
       LDX  #0
       SWI
       STX  PPEMP,U
       LDA  #ALSEM
       LDX  #PPBFLN  ALLOCATE FULL SEMP
       SWI
       STX  PPFULL,U
       LDA  #ALSEM
       LDX  #1       ALLOCATE MUTEX SEMP FOR PIPE
       SWI
       STX  PPMUTX,U
       CLR  PPCLS,U  SET DONE FLAG OFF
       CLR  PPPCB,U   SET PCB LINK OFF (NOT USED)
       CLR  PPPCB+1,U
       LEAY PPBUFF,U  FIND BUFFER ADDRESS
       STY  PPPTR,U   SAVE IN PIPE
       LDY  PIPLST    LIKE PIPE INTO CHAIN
       STY  PPNEXT,U  OF ALL PIPES
       STU  PIPLST
       JMP  [PIPRET]  RETURN TO CALLER

*------------------------------------
*OPENREAD
* IN:B=DEVICE#
*   IF FILE:
*    Y=ADDRESS OF FILE/EXT/DRV
*OUT:A=ERRCODE
*------------------------------------
STKSV  RMB  2       TO SAVE STACK

OPENR  STB  DEVR    SAVE DEVICE IN TEMP
       LDA  #P      MUTEX ON OPEN
       LDX  #OPNSEM
       SWI
       CLR  GENR    NOT GENERAL OPEN

OREADY CMPB #1      DEVICE=CONSOLE?
       LBLS OE2     YES, IGNORE
       LDX  #CONTOP ELSE FIX RETURN ADDRESS
       STX  PIPRET  FOR PIPE ALLOCATION
       CMPB #3      =PIPE?
       LBNE HUHWAT  NO,SKIP
       LDX  ,Y      YES, SAVE READ PIN
       STX  RPIN1
       LDX  2,Y     SAVE WRITE PIN
       STX  RPIN2
       LBRA GPIPE   GET THE PIPE

HUHWAT CLRB         FLAG=0/READ
       LDX  RUN     SAVE STACK
       LDU  PSTK,X  GET STACK LOC
       STU  STKSV   SAVE IN TEMP
       JSR  SCOFT   GO OPEN SUBR
       LDX  RUN     RESTORE STACK
       LDU  STKSV   GET STACK LOC FROM TEMP
       STU  PSTK,X  SAVE IN PCB
       CMPB #255    ERROR?
       BEQ  OPNERR  YES
       CMPB #254    FILE IN USE,WAIT
       BNE  CONTOP  NO WAIT
       INC  DSKREQ  ONE MORE DISK REQ
       LDX  #FILSEM
       LDA  #P      BLOCK UNTIL A FILE CLOSES
       SWI
       BRA  HUHWAT  TRY AGAIN!

CONTOP CLRA         NO ERROR
       BRA  OE2
OPNERR LDA  #255    NO FILE EXISTS!
OE2    LDY  RUN
       LDU  PSTK,Y  PASS BACK CODE
       STA  1,U     IN A

       LDA  DEVR    GET DEV
       CMPA #3      =PIPE?
       BNE  NORPE   NO, SKIP
       LDU  RUN     ELSE GET RUN
       LDU  PSTK,U  GET STACK PCB OF RUN
       LDA  PIPE    GET PIPE #
       STA  2,U     SAVE IN MINOR DEVICE
NORPE  TST  GENR    GEN OPEN OR SPECIFIC?
       BEQ  OPDNE   READING THEN DONE
       LDX  GNPC1   GET PIN#1
       LDB  DEVR    CHECK DEVICE
       CMPB #3      =PIPE?
       BEQ  GPNUM   GO DO PIPE CASE

       LDA  FILE    ELSE GET FILE#
       INC  FILE    BUMP FILE #
       TST  OROW    READ OR WRITE?
       BNE  ORWRT   =1 THEN WRITE CASE
       STB  PRD,X   SAVE MAJ DEV
       STA  PRD+1,X SAVE MIN DEV
       BRA  LSTOPN  DONE!

ORWRT  STB  PWT,X   WRITE CASE SAVE MAJ DEV
       STA  PWT+1,X SAVE MIN DEV
       BRA  LSTOPN  DONE!

GPNUM  LDA  PIPE    PIPES, GET PIPE #
       STB  PRD,X   SAVE MAJ DEV#
       STA  PRD+1,X SAVE MIN DEV #
       LDX  GNPC2   GET WRITE PCB
       STB  PWT,X   SAVE MAJ DEV IN WRITE PCB
       STA  PWT+1,X SAVE MAJ DEV# IN READ PCB

LSTOPN LDU  RUN     GET RUN
       LDU  PSTK,U  GET STACK LOC
       STA  2,U     SAVE FILE# OR PIPE# IN REG B
OPDNE  LDA  #V      DO AN UP ON OPEN SEMP
       LDX  #OPNSEM
       SWI
       LBRA EXIT    RETURN TO CALLER
*--------------------------
*OPENWRITE(SWI)
* IN:B=DEVICE#
* Y=ADD->FILE/EXT/DRIVE
* A=ERRCODE U=&PIN1-2 PIPE
*--------------------------
STKSV2 RMB  2      TO SAVE STACK

OPENW  LDA  #P      MUTEX FOR ALL OPEN ROUTINES
       LDX  #OPNSEM
       SWI
       CLR  GENR    NOT GENERAL WRITE
       STB  DEVR    SAVE DEV#

OREAWY CMPB #1      DEV=SCREEN?
       LBLS OE2     YES, SKIP THIS STUFF
       LDX  #CONTOP ELSE SAVE RETURN ADD FOR PIPE
       STX  PIPRET
       CMPB #3      IS DEV# A PIPE?
       LBNE WATHUH  NO,SKIP
       LDX  ,Y      ELSE GET READ PIN
       STX  RPIN1   SAVE IN TEMP
       LDX  2,Y     GET WRITE PIN
       STX  RPIN2   SAVE IN TEMP
       LBRA GPIPE   GET A PIPE

WATHUH LDB  #1      1=WRITE
       LDX  RUN     SAVE STACK
       LDU  PSTK,X  GET STK ADD
       STU  STKSV2  SAVE IN TEMP
       JSR  SCOFT   GO OPEN SUBR
       LDX  RUN     RESTORE STACK
       LDU  STKSV2  GET STK ADD FROM TEMP
       STU  PSTK,X  RESTORE

       CMPB #255    FILE NOT EXIST
       LBEQ OPNERR  YES=ERROR
       CMPB #254    FILE ALREADY OPEN?
       LBNE CONTOP  NO CONTINUE
       INC  DSKREQ  YES +1 DSKREQ
       TFR  X,U
       LDX  #FILSEM BLOCK UNTIL FILE CLOSE
       LDA  #P
       SWI
       TFR  U,X     GET ADD OF NAME AGAIN
       BRA  WATHUH  TRY AGAIN
*-------------------------
* SCOFT:(SUB)SCAN FILE LIST
*  AND OPEN A FILE
*  IN:Y=NAME
*     B=0/1 READ WRITE
* OUT:B=ERR CODE
*-------------------------
SVA    RMB  1  REGISTER STORAGE
SVB    RMB  1
SVX    RMB  2
SVBUF  RMB  2  BUFFER ADDRESS

SCOFT  STB  SVB  SAVE
       LDX  OFT  GET OFT TABLE
**SEE IF FILE ALREADY OPEN**
SCLP1  CMPX #0       SCAN OPEN FILES
       BEQ  SCNXT    IF END OF LIST THEN
       LEAU FNAME,X  FILE NOT ALREADY OPEN
       LDB  #12      COMPARE FILENAMES
       JSR  COMP
       TSTB         IF NAMES SAME
       BEQ  RET254  THEN FILE ALREADY OPEN
       LDX  FNEXT,X ELSE GET NEXT FILE
       BRA  SCLP1   CHECK IT
RET254 LDB  #254    254=FILE ALREADY OPEN
       RTS
**READ IN FILE DIRECTORY**
SCNXT  LDB   AN     GET BUFFER FOR DIRECTORY
       LDX   #2816  LENGTH OF DIRECTORY
       LDA   #GET   TYPE=ANY
       SWI
       STX   SVX    SAVE BUFF ADD
       LDX   #DDORG MOVE DISK SETUP INTO DISK
       LDU   #DDH   REQ BLOCK
       LDB   #7     7 BYTES LENGTH
       JSR   MOVE   COPY
       LDX   SVX    RESTORE BUFF
       STX   DDH+4  SAVE IN DSKREQ
       LDA   11,Y   GET DRIVE#
       STA   DDH+1  SAVE IN DISK REQ BLOCK

RDDRA  LDA   #DISK  READ IN DIRECTORY
       LDX   #DDH   X=ADD DSKREQ
       SWI
       LDD   DDH+4  UP BUFF+256
       ADDD  #256
       STD   DDH+4  SAVE IN DISK REQ BLOCK
       INC   DDH+3  NEXT SECTOR
       LDA   DDH+3
       CMPA  #12    IF SEC=12 THEN DONE
       BNE   RDDRA  ELSE READ NEXT SECTOR

       LDU   DDH+4  RESTORE BUFF ADDRESS
       LEAU  -2560,U
       STU   DDH+4  DDH=FAT TABLE
       LEAU  256,U  U=START OF FILE ENTRIES
**VALIDATE FILE ON DISK**
SEANM  LDB   #11    VALIDATE NAME=11 BYTES
       TFR   U,X
       JSR   COMP   COMPARE NAMES
       TSTB
       LBEQ  NMFND  YES,NAMES MATCH
INVAG  LEAU  32,U   GET NEXT NAME IN DIR
       LDA   ,U     IF 1ST BYTE=0
       BEQ   INVAG  THEN BLANK ENTRY
       CMPA  #255   =255 END OR ENTRIES
       LBEQ  NOTFND THEN NOT FOUND
       BRA   SEANM  ERROR!
**FOUND FILE ON DISK BUILD OFT**
NMFND  LDB   AN       BUILD OFT ENTRY
       LDX   #FLEN    GET OFT BLOCK
       LDA   #GET     =TYPE ANY
       SWI
       LDY   OFT      LINK INTO OFT LIST
       STY   FNEXT,X  GET NEXT OF OFT
       STX   OFT      SAVE AS FIRST ENTRY
       LDD   0,U      COPY NAME
       STD   FNAME,X    2 BYTES AT A TIME INTO
       LDD   2,U        OFT
       STD   FNAME+2,X
       LDD   4,U
       STD   FNAME+4,X
       LDD   6,U
       STD   FNAME+6,X
       LDD   8,U
       STD   FNAME+8,X
       LDA   10,U
       STA   FNAME+10,X
       LDA   DDH+1
       STA   FDRIVE,X  DRIVE:COPY OTHER FIELDS
       LDD   DRBYTE,U  SAVE PIONTER INTO BUFFER
       STD   FLAST,X   AS # BYTES IN LAST SECTOR
       LDA   DRGRN,U   SAVE 1ST GRAN#
       STA   FGRAN,X
       LDB   SVB      READ OR WRITE?
       STB   FST,X    SAVE IN OFT
       TSTB           READ OR WRITE CASE?
       BNE   FWRITE   GO WRITE CASE

       TFR   X,D      READ CASE-PUT OFT INTO D
       ADDD  #FBUFF   COMPUTE BUFFER ADDRESS
       STD   FBYTE,X  SVAE BUFFER PTR
**READ 1ST GRANULE INTO BUFFER**
       LDU   DDH+4   SETUP DSKREQ
       TFR   X,Y     PUT REQ ADD INTO Y
       LDB   #1      BASE CASE
       LDA   FGRAN,X COMPUTE SECTOR/TRACK
       BITA  #1      IS THE SECTOR=
       BEQ   NOTOP   TO 10 OR 1
       LDB   #10     FOR THE STARTING SECTOR?
NOTOP  STB   DDH+3   SAVE SECTOR#
       CMPA  #34     IS GRAN PAST DIRECTORY?
       BHS   GRHI    NO
       LSRA          ELSE*2 FOR TRACK#
       BRA   GRGO    READ IN IN
GRHI   LSRA          *2+1 FOR TRACK #
       INCA

GRGO   STA   DDH+2   SAVE TRACK#
       TFR   Y,D     GET BUFF ADDRESS 
       ADDD  #FBUFF  SAVE IN REQ BLOCK
       STD   DDH+4   READ IN GRANULE
       LDB   #9     READ 9 SECTORS
DLP2   LDA   #DISK
       LDX   #DDH    CALL A DISK REQUEST
       SWI
       INC   DDH+3   GET NEXT SECTOR
       LDX   DDH+4   NEXT LOC IN BUFFER
       LEAX  256,X
       STX   DDH+4
       DECB          ONE LESS READ
       BNE   DLP2    =0 THEN STOP

       LDA   FGRAN,Y  FIND NEXT GRANULE
       LDA   A,U      SAVE IN OFT
       STA   FGRAN,Y
       CLRB           SET ERROR CODE=0
       TFR   U,X      ERR=0 RETURN
       LBRA  FRDIR    DONE

**OPEN AN EXISTIG FILE TO APPEND**
FWRITE LDU   DDH+4   U=FAT
       TFR   X,Y     Y=OFT
       LDA   FGRAN,Y FIND LAST GRAN OF FILE
FWLP1  CMPA  #68     IF >68 LAST GRAN
       BHI   LSTGRN
       TFR   A,B     SAVE PREV GRAN
       LDA   A,U     GET NEXT GRAN
       BRA   FWLP1
LSTGRN STB   FGRAN,Y SAVE LAST GRAN IN OFT
       ANDA  #63     A=#SECTORS IN GRAN
       STA   SVA     SAVE IT
**SETUP TO READ LAST GRAN OF FILE**
       LDA   #1      COMPUTE SECTOR
       BITB  #1      TO SEE
       BEQ   NOTOP2  IF FOR GRAN STARTS
       LDA   #10     ON SECTOR 10 OR 1
NOTOP2 STA   DDH+3   SAVE SECTOR
       CMPB  #34     IF TGRAN PAST DIR
       BHS   GRHI2   YES CASE 2
       LSRB          NO MULT GRAN*2=TRACK
       BRA   GRGO2   READ IT

GRHI2  LSRB          ELSE GRAN*2+1=TRACK
       INCB
GRGO2  STB   DDH+2    SAVE TRACK
       LEAX  FBUFF,Y  COMPUTE BUFFER ADDRESS
       STX   DDH+4    SAVE IN REQ BLOCK

**READ LAST GRAN INTO OFT**
       LDB   #9       9 SECTORS IN A GRAN
DLP3   LDA   #DISK    CALL A DISK REQ
       LDX   #DDH
       SWI
       INC   DDH+3    NEXT SECTOR
       LDX   DDH+4    NEXT PLACE IN BUFFER
       LEAX  256,X
       STX   DDH+4
       DECB           ON LESS SECTOR
       BNE   DLP3     =0 THEN STOP

DNEDR  LDB   SVA    A=#SECTORS
       TSTB         =0?
       BNE   NMFLL  NO COMPUTE OFFSET
       LDD   #0     YES,NO BYTES IN LAST GRAN
       BRA   ENDOW  GO SAVE IT
NMFLL  DECB         COMPUTE #SECTORS*256
       LDA   #16    SEC*16*16
       MUL
       LDA   #16     =*256
       MUL
       ADDD  FLAST,Y +BYTES IN LAST SECTOR
ENDOW  LEAX  FBUFF,Y +&OFT BUFFER
       PSHS  X       PUT ONTO STACK
       ADDD  ,S      ADD THIS VALUE
       PULS  X       POP VALUE OFF
       STD   FBYTE,Y SAVE INTO BUFF PTR
       CLRB          ERR=0
       TFR   U,X
       LBRA  FRDIR   DONE!
**FILE NOT FOUND, MAKE A NEW ONE**
NOTFND LDB   SVB     READ OR WRITE?
       TSTB
       BNE   MKDIR   =WRITE THEN CONTINUE
       LDB   #255    =READ/ERROR
       LDX   DDH+4   FILE NOT EXIST
       LBRA  FRDIR   QUIT
**MAKE NEW ENTRY IN DIRECTORY**
MKDIR  LDU   DDH+4   U=DIR BUFF
       LEAU  256,U   GOTO FILE AREA
MKLPR  LDA   ,U      FIND OPEN FILE ENTRY
       TSTA
       BEQ   GTENT   BLANK DIR ENTRY?, YES
       CMPA  #255    END OF DIRECTORY?
       BEQ   GTENT   YES, ENTER FILE HERE!

       LEAU  32,U    GO NEXT FILE ENTRY
       BRA   MKLPR   SEE IF OPEN

GTENT  TFR   Y,X     COPY NAME INTO DIR
       LDB   #11     NAME=11 BYTES
       JSR   MOVE    USE SUBROUTINE MOVE
       LDA   #1      SET FILETYPE/MODE
       STA   DRFT,U  SET FILE TYPE
       CLR   DRFM,U   SET FILE MODE
       CLR   DRBYTE,U   NEWFILE #BYTES=0
       CLR   DRBYTE+1,U

       LDY   DDH+4   GET FAT
       STY   SVBUF   SAVE &DIRBUFF
       CLRB
GRNLP  LDA   B,Y     FIND FREE GRAN IN FAT
       CMPA  #255    =255 FREE
       BEQ   FNSPC
       INCB          NEXT GRAN
       BRA   GRNLP   TRY AGAIN
**WRITE BACK DIRECTORY**
FNSPC  LDA   #$C0    1ST/LST SECTOR EMPTY
       STA   B,Y     SAVE IN FAT
       STB   DRGRN,U SAVE GRAN IN FILE ENT
       LDA   #3      =3WRITE
       STA   DDH     SETUP TO WRITE
       LDA   #17     WRITE DIR BACK AT TRACK=17
       STA   DDH+2   SAVE IN REQ
       LDA   #2      SECTOR=2
       STA   DDH+3   SAVE
WRDRA  LDA   #DISK   WRITE DIR TO DISK
       LDX   #DDH    DISK REQ
       SWI
       LDD   DDH+4   NEXT POSITION IN BUFFER
       ADDD  #256
       STD   DDH+4
       INC   DDH+3   NEXT SECTOR
       LDA   DDH+3
       CMPA  #12     DO 12 SECTORS
       BNE   WRDRA   IF=0 THEN STOP

**SETUP AN OFT ENTRY**
       LDB   AN      GET OFT BLOCK
       LDX   #FLEN   TYPE ANY
       LDA   #GET    OF LENGTH OFT
       SWI
       LDY   OFT     LINK INTO OFT LIST
       STY   FNEXT,X SET OLD 1ST ONE IN NEW OFT
       STX   OFT     SET NEW ONE AST 1ST OFT
       EXG   X,U     U=OFT
       LEAU  FNAME,U TAB OVER TO NAME
       LDB   #11     COPY NAME
       JSR   MOVE    USE MOVE SUB
       LEAU  -FNAME,U RETORE OLD POINTER VAL
       EXG   X,U     SWITCHERO
       LDA   #1      =WRITE ONLY
       STA   FST,X   SETUP DRIVE/GRAN
       LDA   DDH+1    GET DRIVE#
       STA   FDRIVE,X SET DRIVE FOR OFT
       LDA   DRGRN,U  GET 1ST GRAN #
       STA   FGRAN,X  SET IN OFT
       LDD   #0       LAST CURRENTLY=0
       STD   FLAST,X LAST/BUFF/BYTE=0
       LEAY  FBUFF,X   BUFFER=0
       STY   FBYTE,X   BUFFER INDEX=0
CLRBF  CLR   ,Y+     CLEAR OFT BUFFER(NEATNESS)
       ADDD  #1
       CMPD  #2560   LENGTH
       BNE   CLRBF

       CLRB          ERRS=0
       LDX   SVBUF   GET &DIRBUFF
FRDIR  LDA   #FREE   FREE DIRBUFF
       SWI
       RTS (RETURN TO MAIN OPEN ROUT)
*-----------------
*DISK READ HANDLER
* RUNS AS PROCESS
*-----------------
*LOCAL VARS*
FAT    RMB   256 HOLD A TEMP FAT TABLE
RDTMP  RMB   1   GRAN SAVE
DRSTK  RMB   2   STACK SAVE
USV    RMB   2   U=REG
YSV    RMB   2   Y=REG
HHH    RMB   10  DSKREQ BLOCK
ERRMSG FDB   3   ERR/#BYTES READ
       RMB   3

DREAD  LDA   #REC   WAIT FOR REQUEST
       SWI
       CLR   ERRMSG+LENRET+2
       CLR   ERRMSG+LENRET+3

       LDU   RUN     SAVE STACK TO THIS PROCESS
       LDU   PSTK,U  GET STK
       STU   DRSTK   SAVE IN TEMP
       PSHS  X        SAVE VALUE OF MESSAGE
       LEAY  TMSG,X    GET MSG PART
       LEAY  IONAME,Y  GET NAME PART
       LDU   OFT       FIND OFT ENTRY
GETOFT LEAU  FNAME,U   COMPARE NAMES IN OFT'S
       STU   USV       SAVE U AND Y IN TEMP
       STY   YSV
       LDB   #12       COMPARE 12 BYTES
CMPLS1 LDA   ,Y+
       CMPA  ,U+
       BNE   CHKDN2    NOT EQUAL THEN GET NEXT OFT
       DECB            ONE LESS BYTE
       BNE   CMPLS1    LOOP

CHKDN2 LDU   USV       RESTORE U AND Y
       LDY   YSV
       TSTB            IF B=0 THEN THEY ARE =
       BEQ   GOTNME    YES, HAVE THE NAME
       LEAU  -FNAME,U  RESTORE POINTER
       LDU   FNEXT,U   GET NEXT OFT ENTRY
       CMPU  #0        =0
       LBEQ  DRERR     YES, ERROR
       BRA   GETOFT    ELSE TRY TO COMPARE AGAIN

DRERR  LDA   #254      SET ERROR
       LBEQ  SETEND    GO END

GOTNME LEAY  -IONAME,Y   RETORE POINTERS
       LEAU  -FNAME,U
RDLP   LDX   IOLEN,Y    COPY BYTES FROM BUFFERS
       CMPX  #0         TO ADDRESS FROM IOBLOCK
       BNE   NOENDF    LEN =0 DONE WITH TRANSFER
       CLRA            ERRS=0
       LBRA  SETEND    GO END

NOENDF LDA   FGRAN,U   LAST GRAN?
       CMPA  #$C0
       LBLO  NORMDR    NO, NORMAL READ
       ANDA  #$3F      YES, MASK OF GRAN
       STA   RDTMP     SAVE IN TEMP
       LEAX  FBUFF,U   SAVE BUFF ADD
       PSHS  X
       LDD   FBYTE,U   GET ADD OF POINTER
       SUBD  ,S        COMPUTE DIFFERENCE
       PULS  X
       DEC   RDTMP     ONE LESS SECTOR TO READ
ADJLP  TST   RDTMP     =0 YET?
       BEQ   NOADJ     NO DONT ADJUST
       SUBD  #256      ELSE FIX LENGTH TO READ
       CMPD  #$FEFF    IS IT NEGATIVE?
       BHI   DCOPY1    NO NORMAL COPY
       DEC   RDTMP     ELSE SECTORS=0
       BRA   ADJLP     GO TROUGH ALL GRANS

NOADJ  CMPD  FLAST,U   LAST BYTES?
       LBLO  DCOPY1    NO,SKIP
EOF    LDA   #255      EOF
       LBRA  SETEND    SET END OF FILE AND FINISH

DCOPY1 LDX   FBYTE,U   COPY ONE BYTE
       LDA   ,X+       GET IT
       STX   FBYTE,U   SAVE IN BUFF
       LDX   IOADD,Y   UP READ ADDRESS
       STA   ,X+
       STX   IOADD,Y
       LDX   IOLEN,Y   DEC LENGTH OF READ
       LEAX  -1,X
       STX   IOLEN,Y   SET #OF BYTES READ
       LDX   ERRMSG+LENRET+2
       LEAX  1,X
       STX   ERRMSG+LENRET+2
       LBRA  RDLP

NORMDR LEAX  FBUFF,U   DETERMINE IF NEW GRANULE
       PSHS  X         SHOULD BE READ IN
       LDD   FBYTE,U   GET BUFF POINTER
       SUBD  ,S        COMPUTE DIFFERENCE
       PULS  X         POP TEMP VAL
       CMPD  #2304     END OF A GRANULE?
       LBLO  DCOPY1    NO CARRY ON

       LDA   #2       COPY THE GRANULE
       STA   HHH      READ NEW GRANULE FROM 
       LDA   FDRIVE,U DISK INTO OFT BUFFER
       CLRA
       STA   HHH+1    DRIVE=0
       LEAX  FBUFF,U
       STX   HHH+4     FIX BUFFER ADDRESS FOR REQ
       LDA   FGRAN,U   GET GRAN
       LDB   #1        COMPUET SECTOR
       BITA  #1        FROM GRAN ADDRESS
       BEQ   NOTOP4
       LDB   #10       TO SEE IF = 10 OR 1
NOTOP4 STB   HHH+3     COMPUTE TRACK
       CMPA  #34       PAST DIR TRACK?
       BHS   GRHI4     YES
       LSRA            ELSE TRACK=GRAN*2
       BRA   GRGO4     GO READ IT
GRHI4  LSRA            TRACK=GRAN*2+1
       INCA
GRGO4  STA   HHH+2     SAVE TRACK

       LDB   #9        READ 9 SECTORS
DLP4   LDA   #DISK     DISK REQ
       LDX   #HHH
       SWI
       INC   HHH+3     NEXT SECTOR
       LDX   HHH+4     NEXT BUFFER
       LEAX  256,X     ENTRY
       STX   HHH+4
       DECB            ONE LESS SECTOR
       BNE   DLP4      LOOP UNTIL 0
**READ IN FAT**
       LDA   #2        =READ
       STA   HHH
       LDA   FDRIVE,U  GET DRIVE
       STA   HHH+1     SET IN RQ
       LDA   #17    LOAD FAT TABLE
       STA   HHH+2  SECTOR=2
       LDA   #2      TRACK=17
       STA   HHH+3   READ AT FAT TABLE ENTRY
       LDX   #FAT
       STX   HHH+4
       LDA   #DISK   DO 1 DISK REQ
       LDX   #HHH
       SWI
       LDA   FGRAN,U   GET NEXT GRAN IN FILE
       LDX   #FAT
       LDA   A,X
       STA   FGRAN,U   SAVE IN OFT
       LEAX  FBUFF,U   NEW BUFFER LOC
       STX   FBYTE,U   =START OF BUFFER
       LBRA  DCOPY1    LOOP

SETEND STA   ERRMSG+ERRRET+2
JIFH   PULS  X        GET RET PIN
       LDX   TSEND,X  GET SENDERS PIN
       LDY   #ERRMSG   GET ERRMSG ADD
       LDA   #SEND     SEND IT TO IO HANDLER
       SWI
       LDU   RUN       FIX STACK
       LDX   DRSTK
       STX   PSTK,U
       LBRA  DREAD     WAIT FOR ANOTHER REQUEST
*----------------
* DISK WRITE
* RUNNING PROCESS
*----------------
FAW    RMB   256  HOLD A TEMP FAT TABLE
RDTMW  RMB   1    READ ADD
DRSTW  RMB   2    TEMP
HHW    RMB   10   DISK REQ LOC
SWX2   RMB   2    TEMPS
SSWX   RMB   2
UWS    RMB   2    SAVE REGS
YWS    RMB   2
ERRMSW FDB   3    RETURN MSG
       RMB   3

DWRITE LDA   #REC  REQUEST FOR WRITE?
       SWI
       CLR   ERRMSW+LENRET+2
       CLR   ERRMSW+LENRET+3

       STX   SSWX      SAVE PIN OF RET ADDRESS
       LEAY  TMSG,X    GET MESSAGE PART
       LEAY  IONAME,Y  GET NAME
       LDU   OFT       FIND OFT ENTRY
GETOFW LEAU  FNAME,U   WITH SAME NAME
       STU   UWS       SAVE Y AND U
       STY   YWS
       LDB   #12       COMPAR 12 BYTES FOR NAME
CMPLSW LDA   ,Y+
       CMPA  ,U+
       BNE   CHKDNW    NOT EQUAL THEN GET NEXT
       DECB            ON LESS
       BNE   CMPLSW    IF=0 THEN FOUNT IT!

CHKDNW LDU   UWS       RESTORE U AND Y
       LDY   YWS
       TSTB            =0
       BEQ   GOTNMW    THEN GOT NAME
       LEAU  -FNAME,U  ELSE RESTORE OFT
       LDU   FNEXT,U   GET NEXT OFT
       CMPU  #0        =0
       LBEQ  DRERW     THEN ERROR
       BRA   GETOFW    COMPARE THIS NAME

DRERW  LDA   #255      ELSE SET ERROR
       LBEQ  SETENW    CODE

GOTNMW LEAY  -IONAME,Y  FIX POINTERS
       LEAU  -FNAME,U
RDLW   LDX   IOLEN,Y    COPY BYTES FROM BUFFERS
       CMPX  #0         TO ADDRESS FROM IOBLOCK
       BNE   NORMDW     NORMAL WRITE
       CLRA             ERRORS=0
       LBRA  SETENW    DONE WITH READ!

DCOPYW LDX   IOADD,Y   GET BYTE FROM BUFF
       LDA   ,X+       SAVE INTO LOC
       STX   IOADD,Y   NEXT BYTE
       LDX   FBYTE,U   UP OFT BYTE ADD
       STA   ,X+
       STX   FBYTE,U
       LDX   IOLEN,Y   ONE LESS TO WRITE
       LEAX  -1,X
       STX   IOLEN,Y   FIX # BYTES WRITTEN
       LDX   ERRMSW+LENRET+2
       LEAX  1,X
       STX   ERRMSW+LENRET+2
       LBRA  RDLW      WRITE NEXT BYTE

NORMDW LEAX  FBUFF,U   DETERMINE IF NEW GRANULE
       STX   SWX2      SHOULD BE READ IN
       LDD   FBYTE,U
       SUBD  SWX2      COMPUTE DIFFERENCE
       CMPD  #2304     GREATER THEN GRAN LENGTH?
       LBLO  DCOPYW    NO NORMAL CASE

       LDA   #3       COPY THE GRANULE
       STA   HHW       SAVE AS COMMAND
       LDA   FDRIVE,U  =WRITE
       CLRA            DRIVE =0
       STA   HHW+1
       LEAX  FBUFF,U   SUT BUFF ADD FOR REQ
       STX   HHW+4
       LDA   FGRAN,U   TO COMPUTE SECTOR AND TRACK
       LDB   #1
       BITA  #1        SECTOR 10
       BEQ   NOTOPW    OR 1?
       LDB   #10
NOTOPW STB   HHW+3
       CMPA  #34       TRACK CASES
       BHS   GRHIW     FOR BEFORE AND AFTER
       LSRA            DIRECTORY
       BRA   GRGOW
GRHIW  LSRA
       INCA
GRGOW  STA   HHW+2

       LDB   #9        WRITE 9 SECTORS
DLPW   LDA   #DISK
       LDX   #HHW      DISK REQUEST
       SWI
       INC   HHW+3     NEXT SECTOR
       LDX   HHW+4
       LEAX  256,X     NEXT BUFFER LOC
       STX   HHW+4
       DECB            ONE LESS WRITE
       BNE   DLPW      =0 THEN DONE

       LDA   #2        READ IN FAT TABLE
       STA   HHW      COMM=READ
       LDA   FDRIVE,U   GET DRIVE
       STA   HHW+1     SAVE AS REQ
       LDA   #17    LOAD FAT TABLE
       STA   HHW+2     TRACK=17
       LDA   #2        SECTOR=2
       STA   HHW+3
       LDX   #FAW
       STX   HHW+4     SAVE BUFF ADDRESS FOR FAT
       LDA   #DISK
       LDX   #HHW      DO THE REQ
       SWI

       LDX   #FAW      FIND THE NEXT GRANULE
       CLRB            TO WRITE TO
SWLK   LDA   B,X       GET GRAN
       CMPA  #255      EMPTY?
       BEQ   GTGNW     YES USE THIS ONE
       INCB            ELSE CHECK NEXT GRAN
       BRA   SWLK      TRAY AGAIN

GTGNW  LDA   FGRAN,U   SAVE GRAN
       STB   A,X       TO BE ALLOCATED
       STB   FGRAN,U   SO THE LAST ONE LINKS
       LDA   #$C0      TO IT
       STA   B,X
       INC   HHW       WRITE FAT BACK TO DISK
       LDX   #HHW
       LDA   #DISK     DO READ REQUEST
       SWI
       LEAX  FBUFF,U   GET BUFF ADDRESS
       STX   FBYTE,U   START BACK AT 0 AGAIN
       JMP   DCOPYW    COPY NEXT BYTE

SETENW STA   ERRMSW+ERRRET+2
JIFW   LDX   SSWX     GET MESSAGE
       LDX   TSEND,X  GET SENDERS PIN
       LDY   #ERRMSW   GET ERROR MSG
       LDA   #SEND     SEND IT TO IO REQ
       SWI
       LBRA  DWRITE    WAIT FOR ANOTHER WRITE REQ

*---------------------
*CLOSE DEVICE:
* IN:Y=&FILENAME/DRIVE
*    B=DEV#
* PIPE 4,Y=PIPE#
*OUT:A=ERR=255 NOERR=0
*---------------------
CLFAT  RMB  256   TO HOLD FAT
DLH    RMB  7     TEMP VARS
CLT    RMB  2
CXS    RMB  2

DKCLS  LDA  #P      MUTEX
       LDX  #OPNSEM FOR ALL OPENS
       SWI
       CMPB #3      =PIPE?
       LBEQ KPIPE   YES, GO PIPE CASE
       CMPB #2      =FILE?
       BEQ  PPORDR   YES, GO FILE CASE
       CLRB            ELSE IGNORE CLOSE
       JMP  CLEND    AND GO TO THE END

PPORDR LDX  OFT      FOR FILE GET OFT START
CLCMP  CMPX #0       LAST ENRTY?
       LBEQ CLERR    YES, ERROR
       LEAU FNAME,X   COMPARE NAMES
       LDB  #11
CHCMP  LDA  B,Y      LENGTH OF 11
       CMPA B,U
       BNE  CLNXT     GET NEXT OFT NAME
       DECB
       BNE  CHCMP     CHECK NEXT BYTE
       LBRA CLFND

CLNXT  LDX  FNEXT,X   GET NEXT OFT ENTRY
       BRA  CLCMP     COMPARE NEW NAME

CLFND  STX  CLT       SAVE NAME ADD
       LDA  #255       SET FLAG
       LDU  OFT        GET 1ST OFT
       CMPU CLT        =ONE TO REMOVE?
       BEQ  CLEZ      YES, CASE#1

CLLP2  CMPU CLT       CASE 2
       BEQ  CLHARD    REMOVE OFT ENTRY
       TFR  U,X       FROM MIDDLE OF
       LDU  FNEXT,U   FILE
       BRA  CLLP2

CLEZ   LDY  FNEXT,U   REMOVE 1ST OFT
       STY  OFT       ENTRY
       LBRA CLRFRD
CLHARD LDY  FNEXT,U   REMOVE ENTRY
       STY  FNEXT,X   FROM MIDDLE
CLRFRD LDB  DSKREQ    ALL FILE REQ. CAN COMPETE
FRSLP  TSTB           =READ OR WRITE
       BEQ  CLRDWT    MUST BE A WRITE
       LDX  #FILSEM   UNBLOCK ALL WAITING FILES
       LDA  #V
       SWI
       DECB           ONE LESS TO UN BLOCK
       BRA  FRSLP     V ON IT

CLRDWT TST  FST,U     READ OR WRITE?
       LBEQ CLDONE    IF READ THEN NO MORE TO DO

       LDB  AN        MUST WRITE LAST GRAN TO DISK
       LDX  #2560     GET BUFFER FOR DIRECTORY
       LDA  #GET
       SWI

       LDA  #2        =READ
       STA  DLH
       STA  DLH+3     SET TRACK
       LDA  FDRIVE,U  SET DRIVE
       STA  DLH+1
       LDA  #17       TRACK=DR
       STA  DLH+2
       STX  DLH+4      FIX BUFFER
       TFR  X,Y
       LDB  #10        READ 10 SECTORS
CLDL1  LDA  #DISK
       LDX  #DLH       DO READ
       SWI
       LDX  DLH+4   UP BUFFER ADDRESS
       LEAX 256,X
       STX  DLH+4
       INC  DLH+3   NEXT SECTOR
       DECB         ONE LESS TO READ
       BNE  CLDL1   =0 THEN QUIT ELSE READ NEXT
       LDY  DLH+4
       LEAY -2560,Y  UP BUFFER
       STY  DLH+4

       LEAY FBUFF,U  GET BUFFER ADDRESS
       STY  CXS      SAVE IN TEMP
       LDD  FBYTE,U  GET IS BYTE IN ENTRIES
       SUBD CXS      FIND DIFFERENCE
       TFR  D,Y      INTO Y
       CMPD #0       =0
       BEQ  CLGRN      THEN GRANULE IS CLEAR
       LDB  #1      B= # OF SECTORS REQUIRED
DECSEC CMPY #256     =LAST?
       BLS  CLGRN    IF LOWER THAN DONE
       LEAY -256,Y   ELSE -1 SECTOR FROM BUFFER
       INCB          ONE MORE SECTOR TO WRITE
       BRA  DECSEC   LOOP

CLGRN  ORB  #$C0     TACK ON SPECIAL CODE
       LDX  DLH+4    GET ADDRESS
       LDA  FGRAN,U  FOR GRAN BUFFER
       STB  A,X      SAVE IN FAT
       LDX  DLH+4    GET BUFF
       LEAX 256,X    UP TO NEXT VAL
       LEAU FNAME,U  COMPY NAME
       LDB  #0       INTO DIR ENTRY
CLCMP2 LDA  B,X
       CMPA B,U
       BNE  NXTCL
       INCB          LEN OF COPY=11 BYTES
       CMPB #11
       BEQ  CLFN
       BRA  CLCMP2

NXTCL  LEAX 32,X     GO UNTIL FREE
       CLRB          DIR ENTRY APPEARS
       BRA  CLCMP2

CLFN   LEAU -FNAME,U  COMPUTE BUFF ADD
       STY  DRBYTE,X
       INC  DLH       NOW WRITE FAT BACK
       LDA  #2        SECTOR=2
       STA  DLH+3
       LDA  FDRIVE,U  GET DRIVE
       STA  DLH+1     SAVE FOR REQ
       LDA  #17       TRACK=17
       STA  DLH+2     SAVE 
       LDB  #10        WRITE 10 SECS
CLDL2  LDA  #DISK
       LDX  #DLH    DO REQ
       SWI
       LDX  DLH+4
       LEAX 256,X   UP BUFF VAL
       STX  DLH+4
       INC  DLH+3   NEXT SECTOR
       DECB
       BNE  CLDL2   DONE?
       LDX  DLH+4    YES
       LEAX -2560,X  FREE THIS TEMP BUFFER
       LDA  #FREE
       SWI

       LEAX FBUFF,U  GET BUFF ADDRESS
       STX  DLH+4
       LDA  FGRAN,U  GET 1ST GRAN
       LDB  #1
       BITA #1
       BEQ  NOTOP6   COMPTUE SECTOR
       LDB  #10
NOTOP6 STB  DLH+3
       CMPA #34
       BHS  GRHI6    COMPUTE TRACK
       LSRA
       BRA  GRGO6
GRHI6  LSRA
       INCA
GRGO6  STA  DLH+2    SAVE TRACK
       LDB  #9       (WRITE)
DLP6   LDA  #DISK
       LDX  #DLH
       SWI           DO REQ FOR GRAN
       INC  DLH+3    NEXT SECTOR
       LDX  DLH+4
       LEAX 256,X    NEXT BUFFER
       STX  DLH+4
       DECB          DONE?
       BNE  DLP6     NO

CLDONE CLRB         YES, FREE THE OFT
       LDA  #FREE
       LDX  CLT
       SWI
       BRA  CLEND   ERRS=0
CLERR  LDB  #255    IO ERROR
CLEND  LDU  RUN      RETURN
       LDU  PSTK,U   ERROR CODE
       STB  1,U      IN REG A
       LDA  #V
       LDX  #OPNSEM  UNBLOCK ANY FOR OPEN SEMP
       SWI
       LBRA EXIT    DONE!

*--------------
*KILL A PIPE
* AT 4,Y=PIPE#
*--------------
KPIPE  LDB  4,Y      GET PIPE#
       LDX  PIPLST   START OF PIPELIST
       CMPB PPNUM,X  CHECK 1ST
       LBEQ KPEZ     FOUND=#1
KPLP   CMPB PPNUM,X  CHECK NEXT ONES
       LBEQ KPHAD    FOUND AFTER 1ST
       TFR  X,U      LASTPIPE=U
       LDX  PPNEXT,X NEXT PIPE
       CMPX #0       END LIST?
       LBEQ CLERR    YES,ERROR
       BRA  KPLP     CHECK NEXT

KPHAD  LDY  PPNEXT,X REMOVE PIPE
       STY  PPNEXT,U FROM MIDDLE OF LIST
       BRA  FPIPE
KPEZ   LDY  PPNEXT,X REMOVE PIPE FROM
       STY  PIPLST   START OF LIST
FPIPE  TFR  X,Y      PIPE=U
       LDX  PPEMP,Y  FREE WAITING PROCS
       LDA  #V       BUT UNBLOCK 1ST
       SWI
       LDX  PPEMP,Y
       LDA  #FRSEM   FREE EMPTY
       SWI
       LDX  PPFULL,Y  UNBLOCK FOR FULL
       LDA  #V
       SWI
       LDX  PPFULL,Y
       LDA  #FRSEM   FREE FULL
       SWI
       LDX  PPMUTX,Y
       LDA  #V       UNBLOCK FOR MUTX
       SWI
       LDX  PPMUTX,Y
       LDA  #FRSEM   FREE MUTX
       SWI
       TFR  Y,X      FREE PIPE
       LDA  #FREE
       SWI
       CLRB          ERR=0
       LBRA CLEND    RETURN

*-----------
*PIPE READ
*SERVER PROC
*-----------
PER    FDB 3  ERR/#BYTES
       RMB 3  RETURN MSG
PMSGS  RMB 2  PIN REQUESTER

PIPRD  LDA  #REC     GET IO BLOCK
       SWI           LEN TRANS=0
       CLR  PER+LENRET+2
       CLR  PER+LENRET+3
       STX  PMSGS
       LEAU TMSG,X     MSG PART
       LDA  IONAME+4,U GET PIPE#
       LDY  PIPLST     VERIFY PIPE#
PRDL   CMPA PPNUM,Y  SAME#?
       LBEQ PRGTP    YES,MATCH
       LDY  PPNEXT,Y NO,NEXT
       CMPY #0       END OF LIST?
       LBEQ PRERR    YES,ERR
       BRA  PRDL     NO,CHECK NEXT

PRGTP  LDA  #P
       LDX  PPMUTX,Y  P ON MUTX
       SWI
       LDX  IOLEN,U  END OF TRANSFER?
       CMPX #0
       BNE  NOENP    NO
       CLRA          YES,ERR=0
       LBRA SETENV
NOENP  LDA  #V
       LDX  PPMUTX,Y  V ON MUTX
       SWI
       LDX  PPEMP,Y  ONE LESS TO READ
       LDA  #P
       SWI
       LDX  PPMUTX,Y   P ON MUTX
       LDA  #P
       SWI
       TST  PPCLS,Y  IS PIPE CLOSED?
       BEQ  STILO    NO
       LDA  #255     YES,EOF:QUIT
       LBRA SETENV
STILO  LEAX PPBUFF,Y  GET BYTE FROM BUFFER
       LDA  ,X
       LDX  PPPTR,Y  BYTE FROM PIPE
       LEAX -1,X     ADJUST
       STX  PPPTR,Y  SAVE AS NEW POINTER VAL
       LDX  IOADD,U  TRANSFER BYTE
       STA  ,X+      ADD GOES UP BY 1
       STX  IOADD,U
       LDX  IOLEN,U  DEC LEN
       LEAX -1,X     BY 1
       STX  IOLEN,U  TO BE READ
       LDX  PER+LENRET+2 INC #TRANS
       LEAX 1,X
       STX  PER+LENRET+2
       LDB  #PPBFLN
       LEAX PPBUFF+1,Y
MULLP  LDA  ,X+
       STA  -2,X    SHIFT STUFF IN BUFFER
       DECB          IN BUFFER
       BNE  MULLP   SO BUFFER RESEMBLES
       LDA  #V       A QUEUE
       LDX  PPMUTX,Y
       SWI             V ON MUTX
       LDX  PPFULL,Y ADJUST PROD/CONS
       LDA  #V       SO V ON FULL
       SWI
       LBRA PRGTP   CONTINUE

SETENV TFR  A,B
       LDA  #V      V ON MUTX
       LDX  PPMUTX,Y
       SWI
       TFR  B,A      NO ERROS
       BRA  SETENP
PRERR  LDA  #254     254=ERROR
SETENP STA  PER+ERRRET+2
       LDX  PMSGS    SEND ERR/#BYTES READ
       LDX  TSEND,X  BACK TO IO REQ
       LDY  #PER
       LDA  #SEND
       SWI
       LBRA PIPRD    WAIT NEXT REQ.
*----------
*PIPE WRITE
* (PROC)
*----------
WER    FDB 3   TEMPS
       RMB 3
WMSGS  RMB 2

WIPRD  LDA  #REC     GET IO BLOCK
       SWI           LEN TRANS=0
       CLR  WER+LENRET+2
       CLR  WER+LENRET+3
       STX  WMSGS
       LEAU TMSG,X     MSG PART
       LDA  IONAME+4,U GET PIPE#
       LDY  PIPLST     VERIFY PIPE#
WRDL   CMPA PPNUM,Y  SAME#?
       LBEQ WRGTP    YES,MATCH
       LDY  PPNEXT,Y NO,NEXT
       CMPY #0       END OF LIST?
       LBEQ WRERR    YES,ERR
       BRA  WRDL     NO,CHECK NEXT

WRGTP  LDA  #P
       LDX  PPMUTX,Y  MUTX
       SWI
       LDX  IOLEN,U  END OF TRANSFER?
       CMPX #0
       BNE  WOENP    NO
       CLRA          YES,ERR=0
       LBRA WETENV
WOENP  LDA  #V
       LDX  PPMUTX,Y  OFF MUTX
       SWI
       LDX  PPFULL,Y  ONE LESS TO READ
       LDA  #P
       SWI
       LDX  PPMUTX,Y
       LDA  #P        MUTX
       SWI
       TST  PPCLS,Y  IS PIPE CLOSED?
       BEQ  WTILO    NO
       LDA  #255     YES,EOF:QUIT
       LBRA WETENV
WTILO  LDX  IOADD,U  BYTE FROM ADD
       LDA  ,X+      GET BYTE 
       STX  IOADD,U
       LDX  PPPTR,Y  PUT INTO PIPE
       STA  ,X+
       STX  PPPTR,Y
       LDX  IOLEN,U  DEC LEN
       LEAX -1,X
       STX  IOLEN,U
       LDX  WER+LENRET+2 INC #TRANS
       LEAX 1,X
       STX  WER+LENRET+2
       LDA  #V
       LDX  PPMUTX,Y
       SWI
       LDX  PPEMP,Y ADJUST PROD/CONS
       LDA  #V
       SWI
       LBRA WRGTP   CONTINUE

WETENV TFR  A,B
       LDA  #V
       LDX  PPMUTX,Y
       SWI
       TFR  B,A
       BRA  WETENP
WRERR  LDA  #254     254=ERROR
WETENP STA  PER+ERRRET+2
    
